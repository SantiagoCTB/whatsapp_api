{% extends 'base.html' %}
{% block title %}Agestion{% endblock %}
{% block body_class %}chat{% endblock %}
{% block content %}
  <button id="menuToggle">‚ò∞</button>
  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      <h2>Chats</h2>
      <div class="sidebar-header">
        <button id="settingsBtn">‚öôÔ∏è</button>
      </div>
      <div id="settingsMenu">
        <a href="{{ url_for('configuracion.reglas') }}">Reglas</a>
        <a href="{{ url_for('configuracion.botones') }}">Botones</a>
        {% if session.get('roles') and 'admin' in session['roles'] %}
        <a href="{{ url_for('roles.roles') }}">Roles</a>
        {% endif %}
        <a href="{{ url_for('tablero.tablero') }}">Tablero</a>
        <a id="respuestasLink" href="{{ url_for('chat.respuestas') }}">Respuestas</a>
        <a href="{{ url_for('auth.logout') }}">Cerrar sesi√≥n</a>
      </div>
      <input id="buscador" type="text" placeholder="Buscar n√∫mero‚Ä¶">
      <ul id="chatList"></ul>
      <button id="roleToggle">üé≠</button>
      <div class="role-drop-zone">
        {% for r in roles %}
        <div class="role-icon" data-role="{{ r[2] }}">{{ r[1] }}</div>
        {% endfor %}
      </div>
    </div>

    <!-- Chat Window -->
    <div class="chatWindow">
      <div id="botonera"></div>
      <div id="chatBox"></div>
      <div id="replyPreview" class="reply-preview"></div>
      <div class="inputArea">
        <button id="attachBtn">+</button>
      <div id="attachMenu" class="attach-menu">
        <div id="attachImage" class="attach-item" title="Enviar imagen">üì∑</div>
        <div id="attachAudio" class="attach-item" title="Grabar audio">üé§</div>
        <div id="attachVideo" class="attach-item" title="Enviar video">üé•</div>
      </div>
      <input id="messageInput" type="text" placeholder="Escribe un mensaje‚Ä¶">
      <button id="sendBtn">Enviar</button>
      <input id="imageInput" type="file" accept="image/*" style="display:none;">
      <input id="audioInput" type="file" accept="audio/*" style="display:none;">
      <input id="videoInput" type="file" accept="video/*" style="display:none;">
      <div id="recordControls" class="record-controls" style="display:none;">
        <button id="startRecord" title="Grabar">‚è∫Ô∏è</button>
        <button id="stopRecord" title="Detener" disabled>‚èπÔ∏è</button>
      </div>
    </div>
  </div>
</div>

  <div id="contextMenu" class="context-menu"><div id="replyAction">Responder</div></div>
  <div id="chatContextMenu" class="context-menu chat-context-menu">
    <div id="chatAliasAction">Asignar alias</div>
    <div id="chatFinishAction" class="danger-action">Finalizar chat</div>
    {% if rol == 'admin' %}
    <div id="chatDeleteAction" class="danger-action">Eliminar chat</div>
    {% endif %}
    <div class="menu-divider"></div>
    <div class="menu-header">Estado</div>
    <div id="chatStateOptions" class="menu-options"></div>
  </div>

  <div class="role-indicator">{{ rol }}</div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let currentChat = null, autoRefresh = null, todosChats = [], lastCount = 0, replyTo = null;
      let lastIncomingWaId = null;
      let typingSignalTimeout = null;
      let lastTypingSent = 0;
      const TYPING_SIGNAL_THROTTLE = 2500;
      let selectedBubble = null;
      let chatContextTarget = null;
      const chatListEl = document.getElementById('chatList');
      const chatBoxEl  = document.getElementById('chatBox');
      const botoneraEl = document.getElementById('botonera');
      const replyPreviewEl = document.getElementById('replyPreview');
      const contextMenu = document.getElementById('contextMenu');
      const replyAction = document.getElementById('replyAction');
      const chatContextMenu = document.getElementById('chatContextMenu');
      const chatAliasAction = document.getElementById('chatAliasAction');
      const chatFinishAction = document.getElementById('chatFinishAction');
      const chatDeleteAction = document.getElementById('chatDeleteAction');
      const chatStateOptionsContainer = document.getElementById('chatStateOptions');
      let chatStateOptions = [];
      const chatStateDefinitions = {{ chat_state_definitions | tojson }};
      const chatStateDefinitionMap = new Map();
      chatStateDefinitions.forEach(def => {
        if (def && def.key) {
          chatStateDefinitionMap.set(def.key, def);
        }
      });
      const sendBtn = document.getElementById('sendBtn');
      const messageInput = document.getElementById('messageInput');
      const sidebar = document.querySelector('.sidebar');
      const menuToggle = document.getElementById('menuToggle');
      menuToggle.addEventListener('click', () => {
        sidebar.classList.toggle('visible');
      });
      const roleToggle = document.getElementById('roleToggle');
      const roleDropZone = document.querySelector('.role-drop-zone');
      roleToggle.addEventListener('click', () => {
        roleDropZone.classList.toggle('show');
      });
      function injectChatStateStyles(definitions) {
        if (!Array.isArray(definitions) || definitions.length === 0) {
          const existing = document.getElementById('chat-state-dynamic-styles');
          if (existing) existing.remove();
          return;
        }

        const styleId = 'chat-state-dynamic-styles';
        let styleEl = document.getElementById(styleId);
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }

        const rules = [];
        definitions.forEach(def => {
          if (!def || !def.key) return;
          const bg = def.color || '#666666';
          const text = def.text_color || '#ffffff';
          const key = def.key;
          rules.push(`#chatList li.estado-${key} { background-color: ${bg}; color: ${text}; }`);
          rules.push(`#chatList li.estado-${key}:hover { background-color: ${bg}; color: ${text}; }`);
          rules.push(`#chatList li.estado-${key} .badge { background: rgba(0, 0, 0, 0.18); color: ${text}; }`);
        });
        styleEl.textContent = rules.join('\n');
      }

      function rebuildChatStateOptions() {
        chatStateOptionsContainer.innerHTML = '';

        if (Array.isArray(chatStateDefinitions) && chatStateDefinitions.length) {
          chatStateDefinitions.forEach(def => {
            if (!def || !def.key) return;
            const option = document.createElement('div');
            option.className = 'context-option';
            option.dataset.estado = def.key;

            if (def.color) {
              const colorDot = document.createElement('span');
              colorDot.className = 'state-color-dot';
              colorDot.style.backgroundColor = def.color;
              option.appendChild(colorDot);
            }

            const label = document.createElement('span');
            label.textContent = def.label || def.key;
            option.appendChild(label);

            chatStateOptionsContainer.appendChild(option);
          });
        }

        const clearOption = document.createElement('div');
        clearOption.className = 'context-option';
        clearOption.dataset.estado = '';
        clearOption.textContent = 'Sin estado';
        chatStateOptionsContainer.appendChild(clearOption);

        chatStateOptions = Array.from(chatStateOptionsContainer.querySelectorAll('[data-estado]'));
        chatStateOptions.forEach(option => {
          option.addEventListener('click', () => {
            if (!chatContextTarget) return;
            const chatData = chatContextTarget;
            const estado = option.dataset.estado || null;
            hideChatContextMenu();
            updateChatState(chatData.numero, estado)
              .then(() => fetchChatList())
              .catch(err => console.error(err));
          });
        });
      }

      injectChatStateStyles(chatStateDefinitions);
      rebuildChatStateOptions();
        const userRole   = "{{ rol }}";
        const lastChatTimestamps = {};
        const roleIcons = { ventas: 'üíº', soporte: 'üõ†', marketing: 'üì£' };
        let isSending = false;
        let sendUnlockTimeout = null;
        let lastSentMessage = '';
        let lastSentTimestamp = 0;

        function startSending() {
          if (sendUnlockTimeout) clearTimeout(sendUnlockTimeout);
          isSending = true;
          sendBtn.disabled = true;
          messageInput.readOnly = true;
          sendUnlockTimeout = setTimeout(() => {
            stopSending();
          }, 8000);
        }

        function stopSending() {
          if (sendUnlockTimeout) {
            clearTimeout(sendUnlockTimeout);
            sendUnlockTimeout = null;
          }
          isSending = false;
          sendBtn.disabled = false;
          messageInput.readOnly = false;
        }

        const FLOW_SUMMARY_MAX_ITEMS = 10;
        const EXCLUDED_FLOW_KEYS = new Set(['flow_token']);

        function isExcludedFlowKey(key) {
          return typeof key === 'string' && EXCLUDED_FLOW_KEYS.has(key.toLowerCase());
        }

        function isEmptyFlowValue(value) {
          if (value === null || value === undefined) {
            return true;
          }
          if (typeof value === 'string') {
            return value.trim().length === 0;
          }
          if (Array.isArray(value)) {
            return value.every(item => isEmptyFlowValue(item));
          }
          if (typeof value === 'object') {
            return Object.values(value).every(item => isEmptyFlowValue(item));
          }
          return false;
        }

        function normalizeFlowNode(value) {
          if (Array.isArray(value)) {
            const normalized = [];
            value.forEach(item => {
              const normalizedItem = normalizeFlowNode(item);
              if (!isEmptyFlowValue(normalizedItem)) {
                normalized.push(normalizedItem);
              }
            });
            return normalized;
          }
          if (value && typeof value === 'object') {
            const normalized = {};
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const normalizedValue = normalizeFlowNode(val);
              if (!isEmptyFlowValue(normalizedValue)) {
                normalized[String(key)] = normalizedValue;
              }
            });
            return normalized;
          }
          return value;
        }

        function formatFlowValue(value) {
          if (value === null || value === undefined) {
            return '‚Äî';
          }
          if (typeof value === 'boolean') {
            return value ? 'S√≠' : 'No';
          }
          if (typeof value === 'number') {
            return String(value);
          }
          if (typeof value === 'string') {
            const text = value.trim();
            return text.length ? text : '‚Äî';
          }
          return String(value);
        }

        function flattenFlowData(value, prefix = []) {
          if (Array.isArray(value) || (value && typeof value === 'object')) {
            value = normalizeFlowNode(value);
          }
          const items = [];
          if (Array.isArray(value)) {
            value.forEach((item, idx) => {
              const label = prefix.length ? `Elemento ${idx + 1}` : `Respuesta ${idx + 1}`;
              const nextPrefix = prefix.concat(label);
              if (item && typeof item === 'object') {
                const nested = flattenFlowData(item, nextPrefix);
                if (nested.length) {
                  items.push(...nested);
                }
              } else {
                items.push({
                  label: nextPrefix.join(' ‚Ä∫ '),
                  value: formatFlowValue(item),
                });
              }
            });
            return items;
          }
          if (value && typeof value === 'object') {
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const nested = flattenFlowData(val, prefix.concat(String(key)));
              if (nested.length) {
                items.push(...nested);
              }
            });
            return items;
          }
          const label = prefix.length ? prefix.join(' ‚Ä∫ ') : 'Respuesta';
          items.push({ label, value: formatFlowValue(value) });
          return items;
        }

        function buildFlowValueNode(value) {
          if (Array.isArray(value) || (value && typeof value === 'object')) {
            value = normalizeFlowNode(value);
          }
          if (Array.isArray(value)) {
            const list = document.createElement('ol');
            list.className = 'flow-data-list flow-data-array';
            value.forEach(item => {
              const node = buildFlowValueNode(item);
              if (!node) {
                return;
              }
              const li = document.createElement('li');
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(node);
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list.children.length ? list : null;
          }
          if (value && typeof value === 'object') {
            const list = document.createElement('ul');
            list.className = 'flow-data-list flow-data-object';
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const node = buildFlowValueNode(val);
              if (!node) {
                return;
              }
              const li = document.createElement('li');
              const keySpan = document.createElement('span');
              keySpan.className = 'flow-key';
              keySpan.textContent = key;
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(node);
              li.appendChild(keySpan);
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list.children.length ? list : null;
          }
          const span = document.createElement('span');
          span.className = 'flow-value';
          span.textContent = formatFlowValue(value);
          return span;
        }

        function createFlowCard(flowName, flowJson) {
          const name = typeof flowName === 'string' ? flowName.trim() : '';
          let parsed = null;

          if (flowJson === null || flowJson === undefined) {
            parsed = null;
          } else if (typeof flowJson === 'string') {
            const raw = flowJson.trim();
            if (raw) {
              try {
                parsed = JSON.parse(raw);
              } catch (err) {
                parsed = raw;
              }
            } else {
              parsed = '';
            }
          } else if (typeof flowJson === 'object') {
            parsed = flowJson;
          } else {
            const raw = String(flowJson).trim();
            parsed = raw;
          }

          if (parsed && typeof parsed === 'object') {
            parsed = normalizeFlowNode(parsed);
          }

          const hasRawContent = parsed !== null && parsed !== undefined;
          let hasContent = false;
          if (hasRawContent) {
            if (typeof parsed === 'string') {
              hasContent = parsed.trim().length > 0;
            } else if (Array.isArray(parsed)) {
              hasContent = parsed.length > 0;
            } else if (typeof parsed === 'object') {
              hasContent = Object.keys(parsed).length > 0;
            } else {
              hasContent = String(parsed).trim().length > 0;
            }
          }

          const hasName = name.length > 0;
          if (!hasName && !hasContent) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline';

          if (hasName) {
            const title = document.createElement('p');
            title.className = 'flow-text flow-name';
            title.textContent = name;
            card.appendChild(title);
          }

          let appendedContent = false;

          if (hasRawContent) {
            if (parsed && typeof parsed === 'object') {
              const summaryItems = flattenFlowData(parsed);
              if (summaryItems.length) {
                const list = document.createElement('ul');
                list.className = 'flow-summary';
                summaryItems.slice(0, FLOW_SUMMARY_MAX_ITEMS).forEach(item => {
                  const li = document.createElement('li');
                  li.className = 'flow-summary-item';
                  const key = document.createElement('span');
                  key.className = 'flow-summary-key';
                  key.textContent = item.label;
                  const value = document.createElement('span');
                  value.className = 'flow-summary-value';
                  value.textContent = item.value;
                  li.appendChild(key);
                  li.appendChild(value);
                  list.appendChild(li);
                });
                card.appendChild(list);
                appendedContent = true;
                if (summaryItems.length > FLOW_SUMMARY_MAX_ITEMS) {
                  const remaining = summaryItems.length - FLOW_SUMMARY_MAX_ITEMS;
                  const more = document.createElement('div');
                  more.className = 'flow-summary-more';
                  more.textContent = `+ ${remaining} dato${remaining !== 1 ? 's' : ''} adicional${remaining !== 1 ? 'es' : ''}`;
                  card.appendChild(more);
                }
              } else {
                const isEmptyObject = parsed && !Array.isArray(parsed) && Object.keys(parsed).length === 0;
                const isEmptyArray = Array.isArray(parsed) && parsed.length === 0;
                if (isEmptyObject || isEmptyArray) {
                  const placeholder = document.createElement('p');
                  placeholder.className = 'flow-text';
                  placeholder.textContent = 'Sin contenido';
                  card.appendChild(placeholder);
                  appendedContent = true;
                } else {
                  const node = buildFlowValueNode(parsed);
                  if (node) {
                    card.appendChild(node);
                    appendedContent = true;
                  }
                }
              }
            } else if (typeof parsed === 'string') {
              const textValue = formatFlowValue(parsed);
              if (textValue && textValue !== '‚Äî') {
                const text = document.createElement('p');
                text.className = 'flow-text';
                text.textContent = textValue;
                card.appendChild(text);
                appendedContent = true;
              }
            } else {
              const text = document.createElement('p');
              text.className = 'flow-text';
              text.textContent = formatFlowValue(parsed);
              card.appendChild(text);
              appendedContent = true;
            }
          }

          if (!appendedContent && hasName) {
            const placeholder = document.createElement('p');
            placeholder.className = 'flow-text';
            placeholder.textContent = 'Sin contenido';
            card.appendChild(placeholder);
          }

          return card;
        }

        function createFlowSegmentsCard(segments, originalText) {
          if (!Array.isArray(segments) || !segments.length) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline flow-segments-card';

          let hasContent = false;
          let userLabelShown = false;

          segments.forEach(segment => {
            if (!segment || typeof segment !== 'object') {
              return;
            }

            if (segment.kind === 'text') {
              const content = (segment.content || '').trim();
              if (!content) {
                return;
              }
              const original = (originalText || '').trim();
              if (!userLabelShown && content === original && segments.length === 1) {
                return;
              }
              const p = document.createElement('p');
              p.className = 'flow-text';
              if (!userLabelShown) {
                const label = document.createElement('span');
                label.className = 'flow-label';
                label.textContent = 'Usuario:';
                p.appendChild(label);
                p.appendChild(document.createTextNode(' ' + content));
                userLabelShown = true;
              } else {
                p.textContent = content;
              }
              card.appendChild(p);
              hasContent = true;
              return;
            }

            if (segment.kind === 'data') {
              const content = Array.isArray(segment.content) || (segment.content && typeof segment.content === 'object')
                ? normalizeFlowNode(segment.content)
                : segment.content;
              if (isEmptyFlowValue(content)) {
                return;
              }
              const summary = Array.isArray(segment.summary)
                ? segment.summary.filter(item => item && typeof item.label === 'string' && !item.label.toLowerCase().includes('flow_token'))
                : [];
              if (summary.length) {
                const list = document.createElement('ul');
                list.className = 'flow-summary';
                summary.slice(0, FLOW_SUMMARY_MAX_ITEMS).forEach(item => {
                  if (!item) return;
                  const li = document.createElement('li');
                  li.className = 'flow-summary-item';
                  const key = document.createElement('span');
                  key.className = 'flow-summary-key';
                  key.textContent = item.label;
                  const value = document.createElement('span');
                  value.className = 'flow-summary-value';
                  value.textContent = item.value;
                  li.appendChild(key);
                  li.appendChild(value);
                  list.appendChild(li);
                });
                card.appendChild(list);
                if (summary.length > FLOW_SUMMARY_MAX_ITEMS) {
                  const remaining = summary.length - FLOW_SUMMARY_MAX_ITEMS;
                  const more = document.createElement('div');
                  more.className = 'flow-summary-more';
                  more.textContent = `+ ${remaining} dato${remaining !== 1 ? 's' : ''} adicional${remaining !== 1 ? 'es' : ''}`;
                  card.appendChild(more);
                }
                hasContent = true;
              } else if (segment.display) {
                const trimmed = segment.display.trim();
                if (!trimmed || trimmed === '{}' || trimmed === '[]') {
                  return;
                }
                const pre = document.createElement('pre');
                pre.className = 'flow-json';
                pre.textContent = trimmed;
                card.appendChild(pre);
                hasContent = true;
              } else if (content !== null && content !== undefined) {
                const p = document.createElement('p');
                p.className = 'flow-text';
                p.textContent = formatFlowValue(content);
                card.appendChild(p);
                hasContent = true;
              }
            }
          });

          return hasContent ? card : null;
        }

        function playAlertSound() {
          // El sonido de alerta se deshabilita para evitar el tono al ingresar a la interfaz.
        }

      document.querySelectorAll('.role-icon').forEach(icon => {
        icon.addEventListener('dragover', e => {
          e.preventDefault();
          icon.classList.add('drag-over');
        });
        icon.addEventListener('dragleave', () => icon.classList.remove('drag-over'));
          icon.addEventListener('drop', async e => {
            e.preventDefault();
            icon.classList.remove('drag-over');
            const numero = e.dataTransfer.getData('text/plain');
            const chat   = todosChats.find(c => c.numero === numero);
            const role   = icon.dataset.role;
            const action = (chat && chat.roles_kw && chat.roles_kw.includes(role)) ? 'remove' : 'add';
            const res = await fetch('/assign_chat_role', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ numero, role, action })
            });
            if (res.ok) fetchChatList();
          });
        });

      document.addEventListener('click', () => contextMenu.classList.remove('show'));

      replyAction.onclick = () => {
        if (!selectedBubble) return;
        replyTo = selectedBubble.dataset.waId;
        replyPreviewEl.innerHTML = '';
        const tipo = selectedBubble.dataset.tipo || '';
        const url  = selectedBubble.dataset.url;
        const text = selectedBubble.dataset.text;
        if (url && tipo.endsWith('_image')) {
          const img = document.createElement('img');
          img.src = url; replyPreviewEl.appendChild(img);
        } else if (url && tipo.includes('audio')) {
          const a = document.createElement('audio'); a.controls=true; a.src=url; replyPreviewEl.appendChild(a);
        } else if (url && tipo.includes('video')) {
          const v = document.createElement('video'); v.controls=true; v.src=url; replyPreviewEl.appendChild(v);
        }
        if (text) {
          const p = document.createElement('p'); p.textContent = text; replyPreviewEl.appendChild(p);
        }
        replyPreviewEl.style.display = 'block';
        contextMenu.classList.remove('show');
      };

      replyPreviewEl.onclick = () => {
        replyTo = null;
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
      };

      // Mostrar u ocultar men√∫ settings
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsMenu = document.getElementById('settingsMenu');
      settingsBtn.onclick = e => {
        e.stopPropagation();
        settingsMenu.classList.toggle('show');
      };
      function hideChatContextMenu() {
        chatContextMenu.classList.remove('show');
        chatContextMenu.style.visibility = '';
        chatContextTarget = null;
      }

      function openChatContextMenu(event, chatData) {
        chatContextTarget = chatData;
        chatContextMenu.style.visibility = 'hidden';
        chatContextMenu.classList.add('show');
        chatContextMenu.style.left = `${event.pageX}px`;
        chatContextMenu.style.top = `${event.pageY}px`;
        const rect = chatContextMenu.getBoundingClientRect();
        let left = event.pageX;
        let top = event.pageY;
        if (rect.right > window.innerWidth) {
          left = Math.max(0, window.innerWidth - rect.width - 8);
        }
        if (rect.bottom > window.innerHeight) {
          top = Math.max(0, window.innerHeight - rect.height - 8);
        }
        chatContextMenu.style.left = `${left}px`;
        chatContextMenu.style.top = `${top}px`;
        chatContextMenu.style.visibility = 'visible';
      }

      document.addEventListener('click', e => {
        if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
          settingsMenu.classList.remove('show');
        }
        if (chatContextMenu.classList.contains('show') && !chatContextMenu.contains(e.target)) {
          hideChatContextMenu();
        }
      });
      window.addEventListener('resize', hideChatContextMenu);
      chatListEl.addEventListener('scroll', hideChatContextMenu);
      chatContextMenu.addEventListener('contextmenu', e => e.preventDefault());


      chatAliasAction.addEventListener('click', () => {
        if (!chatContextTarget) return;
        const chatData = chatContextTarget;
        hideChatContextMenu();
        const nombre = prompt(`Asignar alias a: ${chatData.numero}`, chatData.alias || "");
        if (nombre === null) return;
        const trimmed = nombre.trim();
        if (!trimmed) return;
        fetch('/set_alias', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ numero: chatData.numero, nombre: trimmed })
        }).then(() => fetchChatList());
      });

      function resetActiveChatIfMatches(numero) {
        if (currentChat !== numero) return;
        currentChat = null;
        lastCount = 0;
        if (autoRefresh) {
          clearInterval(autoRefresh);
          autoRefresh = null;
        }
        chatBoxEl.innerHTML = '';
        botoneraEl.innerHTML = '';
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
      }

      chatFinishAction.addEventListener('click', () => {
        if (!chatContextTarget) return;
        const chatData = chatContextTarget;
        hideChatContextMenu();
        fetch('/finalizar_chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ numero: chatData.numero })
        })
        .then(resp => {
          if (!resp.ok) throw new Error('No se pudo finalizar el chat');
          resetActiveChatIfMatches(chatData.numero);
          fetchChatList();
        })
        .catch(err => console.error(err));
      });

      if (chatDeleteAction) {
        chatDeleteAction.addEventListener('click', () => {
          if (!chatContextTarget) return;
          const chatData = chatContextTarget;
          hideChatContextMenu();
          const confirmed = confirm(`¬øEliminar el chat ${chatData.numero}? Esta acci√≥n no se puede deshacer.`);
          if (!confirmed) return;
          fetch('/delete_chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ numero: chatData.numero })
          })
          .then(resp => {
            if (!resp.ok) throw new Error('No se pudo eliminar el chat');
            resetActiveChatIfMatches(chatData.numero);
            fetchChatList();
          })
          .catch(err => console.error(err));
        });
      }

      function updateChatState(numero, estado) {
        const payload = { numero };
        payload.estado = estado ? estado : null;
        return fetch('/set_chat_state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        }).then(resp => {
          if (!resp.ok) throw new Error('No se pudo actualizar el estado');
          return resp.json();
        });
      }

      // Cargar lista de chats
      function fetchChatList() {
        hideChatContextMenu();
        fetch('/get_chat_list')
          .then(r=>r.json())
          .then(data=>{
            todosChats = data;
            chatListEl.innerHTML='';
            data.forEach(c => {
              if (userRole !== 'admin') {
                const roles = c.roles_kw || [];
                if (!roles.includes(userRole)) return;
              }
              const serverTime = c.last_timestamp ? new Date(c.last_timestamp).getTime() : null;
              const prevTime = lastChatTimestamps[c.numero];
              if (serverTime && prevTime && serverTime > prevTime && c.numero !== currentChat) {
                const mediaPlaying = Array.from(document.querySelectorAll('audio, video')).some(m => !m.paused);
                if (!mediaPlaying) playAlertSound();
              }
              if (serverTime) lastChatTimestamps[c.numero] = serverTime;
              const li = document.createElement('li');
              li.textContent = c.alias ? `${c.alias} (${c.numero})` : c.numero;
              if (c.estado === 'sin_regla') {
                const alertIcon = document.createElement('span');
                alertIcon.className = 'chat-alert';
                alertIcon.textContent = '‚ö†Ô∏è';
                alertIcon.title = 'Atenci√≥n requerida';
                li.insertBefore(alertIcon, li.firstChild);
              }
              if (c.estado) {
                li.classList.add('estado-' + c.estado);
                const estadoDef = chatStateDefinitionMap.get(c.estado);
                if (estadoDef && estadoDef.label) {
                  li.title = `Estado: ${estadoDef.label}`;
                } else {
                  li.title = `Estado: ${c.estado}`;
                }
              } else {
                li.removeAttribute('title');
              }
              if (currentChat && c.numero === currentChat) {
                li.classList.add('active');
              }

              li.draggable = true;
              li.addEventListener('dragstart', e => {
                e.dataTransfer.setData('text/plain', c.numero);
              });

              // Badges por roles
              li.querySelectorAll('.badge').forEach(b => b.remove());
              li.querySelectorAll('.badges').forEach(bc => bc.remove());
              const badgeContainer = document.createElement('span');
              badgeContainer.className = 'badges';
              if (c.roles_kw && c.roles_kw.length) {
                c.roles_kw.forEach(r => {
                  const badge = document.createElement('span');
                  badge.className = 'badge';
                  badge.textContent = roleIcons[r] || r.charAt(0).toUpperCase();
                  badgeContainer.appendChild(badge);
                });
                li.appendChild(badgeContainer);
              }

              // Al hacer clic, seleccionar el chat
              li.onclick = () => {
                hideChatContextMenu();
                selectChat(c.numero, li);
              };

              // Contextual: alias y estado
              li.addEventListener('contextmenu', e => {
                e.preventDefault();
                openChatContextMenu(e, c);
              });

              chatListEl.appendChild(li);
            });
          });
      }

      // Seleccionar chat
      function selectChat(numero, liEl) {
        currentChat = numero;
        lastCount = 0; // reset count so the initial load doesn't trigger alerts
        lastIncomingWaId = null;
        lastTypingSent = 0;
        // marcar activo
        document.querySelectorAll('#chatList li').forEach(li => li.classList.remove('active'));
        liEl.classList.add('active');
        if (autoRefresh) clearInterval(autoRefresh);
        autoRefresh = setInterval(loadMessages, 3000);
        loadMessages(); loadBotonera();
      }

      // Cargar mensajes
      function loadMessages() {
        if (!currentChat) return;
        // no interrumpir si hay media reproduci√©ndose
        const mediaEls = chatBoxEl.querySelectorAll('audio, video');
        for (let m of mediaEls) if (!m.paused) return;

        fetch(`/get_chat/${currentChat}`)
          .then(r=>r.json())
          .then(data => {
            const msgs = data.mensajes, total = msgs.length;
            const atBottom = chatBoxEl.scrollTop + chatBoxEl.clientHeight >= chatBoxEl.scrollHeight - 5;
            if (lastCount===0 || total<lastCount) {
              chatBoxEl.innerHTML = ''; lastCount = 0;
            }
            let newestIncoming = lastIncomingWaId;
            for (let i=lastCount; i<total; i++){
              const [txt, tipo, url, ts, linkUrl, linkTitle, linkBody, linkThumb,
                     waId, replyWaId, replyId, replyText, replyTipo, replyUrl,
                     flowName, flowJson, flowSegments] = msgs[i];
              const div = document.createElement('div');
              // map tipo a bubble class
              let bubble = 'cliente';
              if (tipo.startsWith('bot'))    bubble='bot';
              if (tipo.startsWith('asesor')) bubble='asesor';
              div.className = `bubble ${bubble} message`;

              if (replyWaId) {
                const replyDiv = document.createElement('div');
                replyDiv.className = 'reply';
                if (replyTipo && replyTipo.endsWith('_image') && replyUrl) {
                  const img = document.createElement('img');
                  img.src = replyUrl;
                  img.style.maxWidth = '100px';
                  replyDiv.appendChild(img);
                } else if (replyTipo && replyTipo.includes('audio') && replyUrl) {
                  const a = document.createElement('audio');
                  a.controls = true; a.src = replyUrl; replyDiv.appendChild(a);
                } else if (replyTipo && replyTipo.includes('video') && replyUrl) {
                  const v = document.createElement('video');
                  v.controls = true; v.src = replyUrl; v.style.maxWidth = '100px';
                  replyDiv.appendChild(v);
                }
                if (replyText) {
                  const p = document.createElement('p');
                  p.textContent = replyText;
                  replyDiv.appendChild(p);
                }
                div.appendChild(replyDiv);
              }

              // insertar media o texto
              if (tipo === 'referral' && linkUrl) {
                const a = document.createElement('a');
                a.href = linkUrl; a.target = '_blank'; a.style.textDecoration = 'none';
                const card = document.createElement('div');
                card.style.display = 'flex';
                const img = document.createElement('img');
                img.src = linkThumb; img.style.width = '100px'; img.style.marginRight = '8px';
                const textBox = document.createElement('div');
                textBox.innerHTML = `<strong>${linkTitle}</strong><br>${linkBody}`;
                card.appendChild(img); card.appendChild(textBox); a.appendChild(card);
                div.appendChild(a);
              } else if (tipo.endsWith('_image') && url) {
                const img = document.createElement('img');
                img.src = url; img.style.maxWidth='200px';
                div.appendChild(img);
              } else if (tipo.includes('audio') && url) {
                const a = document.createElement('audio');
                a.controls=true; a.src=url; div.appendChild(a);
              } else if (tipo.includes('video') && url) {
                const v = document.createElement('video');
                v.controls=true; v.src=url; v.style.maxWidth='200px';
                div.appendChild(v);
              }

              // texto (caption o mensajes)
              if (txt) {
                const p = document.createElement('p');
                p.textContent = txt;
                div.appendChild(p);
              }

              const flowCard = createFlowCard(flowName, flowJson);
              if (flowCard) {
                div.appendChild(flowCard);
              }

              const segmentsCard = createFlowSegmentsCard(flowSegments, txt);
              if (segmentsCard) {
                div.appendChild(segmentsCard);
              }

              // fecha y hora
              if (ts) {
                const date = new Date(ts);
                const timeSpan = document.createElement('div');
                const dia = String(date.getDate()).padStart(2, '0');
                const mes = String(date.getMonth() + 1).padStart(2, '0');
                const hora = String(date.getHours()).padStart(2, '0');
                const min = String(date.getMinutes()).padStart(2, '0');
                timeSpan.className = 'timestamp';
                timeSpan.textContent = `${dia}/${mes} ${hora}:${min}`;
                div.appendChild(timeSpan);
              }

              if (waId) {
                div.dataset.waId = waId;
                if (txt) div.dataset.text = txt;
                if (url) div.dataset.url = url;
                div.dataset.tipo = tipo;
                if (tipo && tipo.startsWith('cliente')) {
                  newestIncoming = waId;
                }
                div.addEventListener('contextmenu', e => {
                  e.preventDefault();
                  e.stopPropagation();
                  selectedBubble = div;
                  contextMenu.style.top = e.pageY + 'px';
                  contextMenu.style.left = e.pageX + 'px';
                  contextMenu.classList.add('show');
                });
              }

              chatBoxEl.appendChild(div);

              if (lastCount > 0 && bubble !== 'asesor') {
                const mediaPlaying = Array.from(chatBoxEl.querySelectorAll('audio, video')).some(m => !m.paused);
                if (!mediaPlaying) playAlertSound();
              }
              lastCount = i + 1;
            }
            lastIncomingWaId = newestIncoming;
            if (atBottom) chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
          });
      }

      // Botones r√°pidos
      function loadBotonera() {
        fetch('/get_botones')
          .then(r=>r.json())
          .then(btns => {
            botoneraEl.innerHTML='';
            btns.forEach((b,i) => {
              const btn = document.createElement('button');
              btn.textContent = b.nombre || i+1;
              btn.onclick = () => {
                if (!currentChat) return;
                const tipoRespuesta = b.tipo || 'texto';
                const envios = [];

                if (['image','video','audio','document'].includes(tipoRespuesta)) {
                  const urls = (b.media_urls && b.media_urls.length) ? b.media_urls : [null];
                  urls.forEach((url, index) => {
                    envios.push(fetch('/send_message', {
                      method:'POST',
                      headers:{'Content-Type':'application/json'},
                      body:JSON.stringify({
                        numero: currentChat,
                        mensaje: index === 0 ? (b.mensaje || '') : '',
                        tipo_respuesta: tipoRespuesta,
                        opciones: url,
                        reply_to_wa_id: replyTo
                      })
                    }));
                  });
                } else {
                  envios.push(fetch('/send_message', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                      numero: currentChat,
                      mensaje: b.mensaje || '',
                      tipo_respuesta: tipoRespuesta,
                      opciones: b.opciones,
                      reply_to_wa_id: replyTo
                    })
                  }));
                }

                Promise.all(envios).then(responses => {
                  if (responses.every(r => r.ok)) {
                    replyTo=null;
                    replyPreviewEl.style.display='none';
                    replyPreviewEl.innerHTML='';
                    loadMessages(); fetchChatList();
                  } else {
                    alert('No se pudo enviar el mensaje');
                  }
                });
              };
              botoneraEl.appendChild(btn);
            });
          });
      }

      // Enviar texto
      sendBtn.onclick = () => {
        if (isSending) return;
        const txt = messageInput.value.trim();
        if (!txt||!currentChat) return;
        const now = Date.now();
        if (txt === lastSentMessage && now - lastSentTimestamp < 1500) return;
        lastSentMessage = txt;
        lastSentTimestamp = now;
        startSending();
        fetch('/send_message',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({numero:currentChat,mensaje:txt,reply_to_wa_id:replyTo})
        }).then(res=>{
          if(!res.ok){
            alert('No se pudo enviar el mensaje');
            lastSentMessage = '';
            lastSentTimestamp = 0;
            stopSending();
            return;
          }
          messageInput.value='';
          replyTo=null;
          replyPreviewEl.style.display='none';
          replyPreviewEl.innerHTML='';
          loadMessages(); fetchChatList();
          stopSending();
        }).catch(err=>{
          console.error('Error enviando mensaje', err);
          lastSentMessage = '';
          lastSentTimestamp = 0;
          stopSending();
        });
      };

      function triggerTypingSignal() {
        if (!currentChat) return;
        const now = Date.now();
        if (now - lastTypingSent < TYPING_SIGNAL_THROTTLE) return;
        lastTypingSent = now;
        fetch('/typing_signal', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            numero: currentChat,
            message_id: lastIncomingWaId,
            include_read: true
          })
        }).catch(err => console.error('Error enviando indicador de escritura', err));
      }

      messageInput.addEventListener('input', () => {
        if (typingSignalTimeout) clearTimeout(typingSignalTimeout);
        typingSignalTimeout = setTimeout(() => {
          typingSignalTimeout = null;
          triggerTypingSignal();
        }, 300);
      });

      messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (!isSending) sendBtn.click();
        }
      });

      // Attach menu
      const attachBtn = document.getElementById('attachBtn');
      const attachMenu = document.getElementById('attachMenu');
      attachBtn.onclick = e => {
        e.stopPropagation();
        attachMenu.classList.toggle('show');
      };
      document.addEventListener('click', () => attachMenu.classList.remove('show'));

      // File inputs y grabaci√≥n de audio
      const imgIn = document.getElementById('imageInput');
      const audIn = document.getElementById('audioInput');
      const vidIn = document.getElementById('videoInput');
      const recordControls = document.getElementById('recordControls');
      const startRecBtn = document.getElementById('startRecord');
      const stopRecBtn  = document.getElementById('stopRecord');
      let mediaRecorder = null;
      let audioChunks = [];
      document.getElementById('attachImage').onclick = () => imgIn.click();
      document.getElementById('attachAudio').onclick = async () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          audIn.click();
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
          mediaRecorder.onstop = async () => {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const file = new File([blob], 'recording.webm', { type: 'audio/webm' });
            await sendRecordedAudio(file);
            mediaRecorder.stream.getTracks().forEach(t=>t.stop());
          };
          recordControls.style.display = 'block';
          attachMenu.classList.remove('show');
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
        } catch(err) {
          audIn.click();
        }
      };
      document.getElementById('attachVideo').onclick = () => vidIn.click();

      startRecBtn.onclick = () => {
        if (mediaRecorder) {
          mediaRecorder.start();
          startRecBtn.disabled = true;
          stopRecBtn.disabled = false;
        }
      };
      stopRecBtn.onclick = () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          recordControls.style.display = 'none';
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
        }
      };

      async function sendFile(inputEl, endpoint) {
        if (!currentChat) return;
        const file = inputEl.files[0];
        if (!file) return;
        const form = new FormData();
        form.append(endpoint.split('_')[1], file);
        form.append('caption','');
        form.append('numero', currentChat);
        const res = await fetch(`/${endpoint}`, { method:'POST', body:form });
        if (!res.ok) return;
        inputEl.value=''; attachMenu.classList.remove('show');
        loadMessages(); fetchChatList();
      }
      async function sendRecordedAudio(file) {
        if (!currentChat) return;
        const form = new FormData();
        form.append('audio', file);
        form.append('caption','');
        form.append('numero', currentChat);
        const res = await fetch('/send_audio', { method:'POST', body: form });
        if (!res.ok) return;
        attachMenu.classList.remove('show');
        loadMessages(); fetchChatList();
      }
      imgIn.onchange = () => sendFile(imgIn, 'send_image');
      audIn.onchange = () => sendFile(audIn, 'send_audio');
      vidIn.onchange = () => sendFile(vidIn, 'send_video');

      // Filtrar chats
      document.getElementById('buscador').addEventListener('input', function(){
        const v = this.value.toLowerCase();
        chatListEl.querySelectorAll('li').forEach(li => {
          li.style.display = li.textContent.toLowerCase().includes(v) ? '' : 'none';
        });
      });

      // Inicializa
      fetchChatList();
      setInterval(fetchChatList, 5000); // intervalo seg√∫n necesidad
      // TODO: sustituir el sondeo por WebSockets o Server-Sent Events para actualizaciones en tiempo real
    });
  </script>
{% endblock %}
