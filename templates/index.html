{% extends 'base.html' %}
{% block title %}WHAPCO{% if tenant_name %} - {{ tenant_name }}{% endif %}{% endblock %}
{% block body_class %}chat{% endblock %}
{% block content %}
  <button id="menuToggle">‚ò∞</button>
  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      {% set session_user = session.get('user') %}
      {% if session_user %}
      <div class="sidebar-greeting">Hola {{ session_user }}!</div>
      {% endif %}
      <h2>Chats</h2>
      <div class="sidebar-header">
        <button id="settingsBtn">‚öôÔ∏è</button>
      </div>
      <div id="settingsMenu">
        <a href="{{ url_for('configuracion.reglas') }}">Reglas</a>
        <a href="{{ url_for('configuracion.botones') }}">Botones</a>
        <a href="{{ url_for('configuracion.configuracion_signup') }}">Integraciones</a>
        {% if session.get('roles') and 'admin' in session['roles'] %}
        <a href="{{ url_for('roles.roles') }}">Roles</a>
        <a href="{{ url_for('usuarios.manage_users') }}">Usuarios</a>
        {% endif %}
        <a href="{{ url_for('tablero.tablero') }}">Tablero</a>
        <a id="respuestasLink" href="{{ url_for('chat.respuestas') }}">Respuestas</a>
        <a href="{{ url_for('auth.logout') }}">Cerrar sesi√≥n</a>
        <label class="settings-toggle">
          <input type="checkbox" id="notificationSoundToggle" checked>
          <span>Sonido de notificaciones</span>
        </label>
        <label class="settings-toggle">
          <input type="checkbox" id="autocorrectToggle">
          <span>Autocorrecci√≥n al escribir</span>
        </label>
        {% if session.get('roles') and 'admin' in session['roles'] %}
        <label class="settings-toggle">
          <input type="checkbox" id="aiToggle" {% if ai_enabled %}checked{% endif %}>
          <span>IA chat activo</span>
        </label>
        {% endif %}
      </div>
      <div class="chat-filters">
        <div class="chat-filters__bar">
          <input id="buscador" type="text" placeholder="Buscar n√∫mero‚Ä¶">
          <button type="button" id="filterToggle" class="filter-toggle" aria-expanded="false" aria-label="Mostrar filtros">
            <span aria-hidden="true">‚ò∞</span>
          </button>
        </div>
        <div id="filterPanel" class="filter-panel" hidden>
          <div class="filter-row">
            <label for="filterState">Estado</label>
            <select id="filterState"></select>
          </div>
          <div class="filter-row">
            <label for="filterRole">Rol</label>
            <select id="filterRole"></select>
          </div>
          <div class="filter-row">
            <label for="filterUser">Usuario</label>
            <select id="filterUser"></select>
          </div>
          <div class="filter-row">
            <label for="filterIntegration">Integraci√≥n</label>
            <select id="filterIntegration">
              <option value="">Todas</option>
              <option value="whatsapp">WhatsApp</option>
              <option value="messenger">Messenger</option>
              <option value="instagram">Instagram</option>
            </select>
          </div>
          <div class="filter-row">
            <label for="filterDateFrom">Desde</label>
            <input type="date" id="filterDateFrom">
          </div>
          <div class="filter-row">
            <label for="filterDateTo">Hasta</label>
            <input type="date" id="filterDateTo">
          </div>
          <label class="filter-toggle-row">
            <input type="checkbox" id="filterShowInactive">
            <span>Mostrar inactivos</span>
          </label>
        </div>
      </div>
      <ul id="chatList"></ul>
    </div>

    <!-- Chat Window -->
    <div class="chatWindow" role="region" aria-label="Zona del chat. Arrastra im√°genes para prepararlas antes de enviar." tabindex="0">
      <div class="chat-header" aria-live="polite">
        <button type="button" id="mobileBackBtn" class="chat-header__btn" aria-label="Volver a la lista de chats">‚Üê</button>
        <img id="mobileChatAvatar" class="chat-header__avatar" alt="Foto de perfil" hidden>
        <div class="chat-header__info">
          <span id="mobileChatTitle" class="chat-header__title">Selecciona un chat</span>
          <span id="mobileChatSubtitle" class="chat-header__subtitle"></span>
        </div>
        <div class="chat-header__actions">
          <button type="button" id="mobileChatActions" class="chat-header__btn" aria-label="Acciones del chat">‚ãÆ</button>
          <button type="button" id="chatFinishButton" class="chat-header__finish" aria-label="Finalizar chat" disabled>Finalizar</button>
        </div>
      </div>
      <div id="botonera"></div>
      <div id="chatBox"></div>
      <div id="replyPreview" class="reply-preview"></div>
      <div class="inputArea">
        <button id="attachBtn">+</button>
      <div id="attachMenu" class="attach-menu">
        <div id="attachImage" class="attach-item" title="Enviar imagen">üì∑</div>
        <div id="attachAudio" class="attach-item" title="Grabar audio">üé§</div>
        <div id="attachVideo" class="attach-item" title="Enviar video">üé•</div>
      </div>
      <div id="imagePreviewChip" class="image-preview-chip" hidden>
        <img id="imagePreviewThumb" alt="Imagen lista para enviar" />
        <button type="button" id="clearImageDraft" aria-label="Quitar imagen">√ó</button>
      </div>
      <div id="videoPreviewChip" class="video-preview-chip" hidden>
        <video id="videoPreviewThumb" muted></video>
        <button type="button" id="clearVideoDraft" aria-label="Quitar video">√ó</button>
      </div>
      <input id="messageInput" type="text" placeholder="Escribe un mensaje‚Ä¶" spellcheck="true" autocorrect="on" autocapitalize="sentences">
      <button id="sendBtn">Enviar</button>
      <input id="imageInput" type="file" accept="image/*" style="display:none;">
      <input id="audioInput" type="file" accept="audio/*" style="display:none;">
      <input id="videoInput" type="file" accept="video/*" style="display:none;">
      <div id="recordControls" class="record-controls" style="display:none;">
        <div class="record-controls__header">
          <span class="record-controls__title">Grabadora de audio</span>
          <span id="recordTimer" class="record-controls__timer" aria-live="polite">00:00</span>
        </div>
        <div class="record-controls__actions">
          <button id="startRecord" class="record-controls__btn record-controls__btn--start" title="Grabar">
            <span class="record-controls__icon" aria-hidden="true">‚è∫Ô∏è</span>
            <span>Grabar</span>
          </button>
          <button id="stopRecord" class="record-controls__btn record-controls__btn--stop" title="Detener" disabled>
            <span class="record-controls__icon" aria-hidden="true">‚èπÔ∏è</span>
            <span>Detener</span>
          </button>
        </div>
        <p class="record-controls__hint">Pulsa grabar para iniciar y detener para enviar.</p>
      </div>
      <div id="audioStatus" class="audio-status" aria-live="polite" hidden></div>
      <div id="videoStatus" class="video-status" aria-live="polite" hidden></div>
    </div>
  </div>
</div>

  <div id="contextMenu" class="context-menu"><div id="replyAction">Responder</div></div>
  <div id="chatContextMenu" class="context-menu chat-context-menu">
    <div id="chatAliasAction">Asignar alias</div>
    <div id="chatFinishAction" class="danger-action">Finalizar chat</div>
    <div id="chatDeleteAction" class="danger-action">Eliminar chat</div>
    <div class="menu-divider"></div>
    <div class="menu-section collapsed" data-section="state">
      <div class="menu-header collapsible">
        <span>Estado</span>
        <span class="menu-header-icon">‚ñ∂</span>
      </div>
      <div id="chatStateOptions" class="menu-options"></div>
    </div>
    <div class="menu-divider"></div>
    <div class="menu-section collapsed" data-section="roles">
      <div class="menu-header collapsible">
        <span>Roles</span>
        <span class="menu-header-icon">‚ñ∂</span>
      </div>
      <div id="chatRoleOptions" class="menu-options"></div>
    </div>
    <div class="menu-divider"></div>
    <div class="menu-section collapsed" data-section="users">
      <div class="menu-header collapsible">
        <span>Usuarios</span>
        <span class="menu-header-icon">‚ñ∂</span>
      </div>
      <div id="chatUserOptions" class="menu-options"></div>
    </div>
  </div>

  {% if rol and rol != 'superadmin' %}
  <div class="role-indicator">{{ rol }}</div>
  {% endif %}

  <div id="imageModal" class="image-modal" role="dialog" aria-modal="true" aria-hidden="true">
    <button type="button" class="close-modal" aria-label="Cerrar vista de imagen">√ó</button>
    <img id="imageModalContent" alt="Imagen del mensaje" />
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let currentChat = null, autoRefresh = null, todosChats = [], lastCount = 0, replyTo = null;
      let lastIncomingWaId = null;
      let messagesRequestSeq = 0;
      let lastRenderedMessagesSeq = 0;
      let lastMessagesFingerprint = null;
      let typingSignalTimeout = null;
      let lastTypingSent = 0;
      let shouldScrollToBottomOnLoad = false;
      const TYPING_SIGNAL_THROTTLE = 2500;
      let chatListPoll = null;
      let socket = null;
      let socketConnected = false;
      let socketFallbackTimer = null;
      let pollingFallbackActive = false;
      let chatListRequestSeq = 0;
      let selectedBubble = null;
      let chatContextTarget = null;
      const notificationSoundUrl = "{{ url_for('static', filename='notificacion.mp3') }}";
      const notificationAudio = notificationSoundUrl ? new Audio(notificationSoundUrl) : null;
      if (notificationAudio) {
        notificationAudio.preload = 'auto';
      }
      let notificationAudioReady = false;
      const notificationSoundToggle = document.getElementById('notificationSoundToggle');
      const SOUND_PREF_KEY = 'chatNotificationSoundEnabled';
      let notificationSoundEnabled = true;
      try {
        const storedPref = localStorage.getItem(SOUND_PREF_KEY);
        if (storedPref === 'false') {
          notificationSoundEnabled = false;
        }
      } catch (err) {
        console.warn('No se pudo leer la preferencia de sonido de notificaciones', err);
      }
      if (notificationSoundToggle) {
        notificationSoundToggle.checked = notificationSoundEnabled;
        notificationSoundToggle.addEventListener('change', () => {
          notificationSoundEnabled = notificationSoundToggle.checked;
          try {
            localStorage.setItem(SOUND_PREF_KEY, notificationSoundEnabled ? 'true' : 'false');
          } catch (err) {
            console.warn('No se pudo guardar la preferencia de sonido de notificaciones', err);
          }
          if (!notificationSoundEnabled && notificationAudio) {
            try {
              notificationAudio.pause();
            } catch (pauseErr) {
              console.warn('No se pudo pausar el sonido de notificaciones', pauseErr);
            }
            notificationAudio.currentTime = 0;
          }
        });
      }
      const autocorrectToggle = document.getElementById('autocorrectToggle');
      const AUTOCORRECT_PREF_KEY = 'chatAutocorrectEnabled';
      let autocorrectEnabled = false;
      try {
        const storedAutocorrect = localStorage.getItem(AUTOCORRECT_PREF_KEY);
        if (storedAutocorrect === 'true') {
          autocorrectEnabled = true;
        }
      } catch (err) {
        console.warn('No se pudo leer la preferencia de autocorrecci√≥n', err);
      }
      if (autocorrectToggle) {
        autocorrectToggle.checked = autocorrectEnabled;
        autocorrectToggle.addEventListener('change', () => {
          autocorrectEnabled = autocorrectToggle.checked;
          try {
            localStorage.setItem(AUTOCORRECT_PREF_KEY, autocorrectEnabled ? 'true' : 'false');
          } catch (err) {
            console.warn('No se pudo guardar la preferencia de autocorrecci√≥n', err);
          }
        });
      }
      const aiToggle = document.getElementById('aiToggle');
      if (aiToggle) {
        aiToggle.addEventListener('change', async () => {
          const desiredState = aiToggle.checked;
          try {
            const response = await fetch('/toggle_ai_enabled', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ enabled: desiredState }),
            });
            const payload = await response.json();
            if (!response.ok || !payload.ok) {
              throw new Error(payload.error || 'No se pudo actualizar el estado de la IA');
            }
            aiToggle.checked = Boolean(payload.enabled);
          } catch (err) {
            aiToggle.checked = !desiredState;
            alert(err.message || 'No se pudo actualizar el estado de la IA');
          }
        });
      }
      function unlockNotificationAudio() {
        if (!notificationAudio || notificationAudioReady) return;
        const originalVolume = notificationAudio.volume;
        notificationAudio.volume = 0;
        const playAttempt = notificationAudio.play();
        if (playAttempt && typeof playAttempt.then === 'function') {
          playAttempt.then(() => {
            notificationAudio.pause();
            notificationAudio.currentTime = 0;
            notificationAudio.volume = originalVolume;
            notificationAudioReady = true;
            document.removeEventListener('click', unlockNotificationAudio);
            document.removeEventListener('keydown', unlockNotificationAudio);
          }).catch(() => {
            notificationAudio.volume = originalVolume;
          });
        } else {
          notificationAudio.volume = originalVolume;
          notificationAudioReady = true;
          document.removeEventListener('click', unlockNotificationAudio);
          document.removeEventListener('keydown', unlockNotificationAudio);
        }
      }
      document.addEventListener('click', unlockNotificationAudio);
      document.addEventListener('keydown', unlockNotificationAudio);
      const chatListEl = document.getElementById('chatList');
      const chatBoxEl  = document.getElementById('chatBox');
      const chatWindowEl = document.querySelector('.chatWindow');
      const buscadorInput = document.getElementById('buscador');
      const filterToggle = document.getElementById('filterToggle');
      const filterPanel = document.getElementById('filterPanel');
      const filterStateSelect = document.getElementById('filterState');
      const filterRoleSelect = document.getElementById('filterRole');
      const filterUserSelect = document.getElementById('filterUser');
      const filterIntegrationSelect = document.getElementById('filterIntegration');
      const filterDateFrom = document.getElementById('filterDateFrom');
      const filterDateTo = document.getElementById('filterDateTo');
      const filterShowInactive = document.getElementById('filterShowInactive');
      const botoneraEl = document.getElementById('botonera');
      const replyPreviewEl = document.getElementById('replyPreview');
      const typingIndicatorEl = document.createElement('div');
      const imageModalEl = document.getElementById('imageModal');
      const imageModalImg = document.getElementById('imageModalContent');
      const imageModalCloseBtn = imageModalEl.querySelector('.close-modal');
      typingIndicatorEl.id = 'typingIndicator';
      typingIndicatorEl.className = 'typing-indicator bubble bot message';
      typingIndicatorEl.innerHTML = `
        <div class="typing-dots" aria-hidden="true">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
      `;
      typingIndicatorEl.setAttribute('role', 'status');
      typingIndicatorEl.setAttribute('aria-live', 'polite');
      const contextMenu = document.getElementById('contextMenu');
      const replyAction = document.getElementById('replyAction');
      const chatContextMenu = document.getElementById('chatContextMenu');
      const chatAliasAction = document.getElementById('chatAliasAction');
      const chatFinishAction = document.getElementById('chatFinishAction');
      const chatDeleteAction = document.getElementById('chatDeleteAction');
      const chatFinishButton = document.getElementById('chatFinishButton');
      const chatStateOptionsContainer = document.getElementById('chatStateOptions');
      const chatRoleOptionsContainer = document.getElementById('chatRoleOptions');
      const chatUserOptionsContainer = document.getElementById('chatUserOptions');
      const chatStateSection = chatContextMenu.querySelector('[data-section="state"]');
      const chatRolesSection = chatContextMenu.querySelector('[data-section="roles"]');
      const chatUsersSection = chatContextMenu.querySelector('[data-section="users"]');
      let chatStateOptions = [];
      const chatStateDefinitions = {{ chat_state_definitions | tojson }};
      const availableRoles = {{ roles | tojson }};
      const availableUsers = {{ users | tojson }};
      const chatStateDefinitionMap = new Map();
      chatStateDefinitions.forEach(def => {
        if (def && def.key) {
          chatStateDefinitionMap.set(def.key, def);
        }
      });
      const roleNameByKeyword = new Map();
      availableRoles.forEach(roleEntry => {
        if (!Array.isArray(roleEntry)) return;
        const roleName = roleEntry[1];
        const roleKeyword = roleEntry[2];
        if (roleKeyword) {
          roleNameByKeyword.set(roleKeyword, roleName || roleKeyword);
        }
      });
      const bogotaFormatter = new Intl.DateTimeFormat('es-CO', {
        timeZone: 'America/Bogota',
        hour12: false,
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });

      function formatBogotaTimestamp(value) {
        if (!value) return '';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return '';
        const parts = bogotaFormatter.formatToParts(date);
        const lookup = {};
        for (const part of parts) {
          if (part.type !== 'literal') {
            lookup[part.type] = part.value;
          }
        }
        const day = lookup.day;
        const month = lookup.month;
        const hour = lookup.hour;
        const minute = lookup.minute;
        if (day && month && hour && minute) {
          return `${day}/${month} ${hour}:${minute}`;
        }
        return bogotaFormatter.format(date);
      }

      function normalizeMediaUrl(u) {
        if (!u) return u;
        try {
          const raw = `${u}`.trim();
          if (!raw) return u;
          const lower = raw.toLowerCase();
          const uploadsMarker = '/static/uploads/';
          if (lower.includes('app.whapco.site') && lower.includes(uploadsMarker)) {
            const idx = lower.indexOf(uploadsMarker);
            if (idx !== -1) {
              return raw.slice(idx);
            }
          }
          if (lower.startsWith('http://')) {
            const httpsVersion = 'https://' + raw.slice('http://'.length);
            const httpsLower = httpsVersion.toLowerCase();
            if (httpsLower.includes('app.whapco.site') && httpsLower.includes(uploadsMarker)) {
              const idx = httpsLower.indexOf(uploadsMarker);
              if (idx !== -1) {
                return httpsVersion.slice(idx);
              }
            }
            return httpsVersion;
          }
          if (lower.startsWith(`https://app.whapco.site${uploadsMarker}`)) {
            const idx = lower.indexOf(uploadsMarker);
            return raw.slice(idx);
          }
          if (lower.startsWith(uploadsMarker)) return raw;
          if (!raw.startsWith('http://') && !raw.startsWith('https://') && !raw.startsWith('/')) {
            return `${uploadsMarker}${raw.replace(/^\/+/, '')}`;
          }
          return raw;
        } catch (err) {
          return u;
        }
      }

      function guessAudioType(url) {
        if (!url) return '';
        const lower = `${url}`.toLowerCase();
        const isSafari = /safari/i.test(navigator.userAgent) && !/chrome|chromium|android/i.test(navigator.userAgent);
        if (lower.includes('.mp3')) return 'audio/mpeg';
        if (lower.includes('.ogg')) return 'audio/ogg';
        if (lower.includes('.webm')) return 'audio/webm';
        if (lower.includes('.wav')) return 'audio/wav';
        if (lower.includes('.m4a')) return 'audio/mp4';
        if (lower.includes('.aac')) return isSafari ? 'audio/mp4' : 'audio/aac';
        return '';
      }

      function createAudioElement(src) {
        const audioEl = document.createElement('audio');
        audioEl.controls = true;
        audioEl.preload = 'metadata';
        const audioType = guessAudioType(src);
        const lower = `${src}`.toLowerCase();
        const isAacVariant = lower.includes('.m4a') || lower.includes('.aac');
        const sourceTypes = audioType ? [audioType] : [];
        if (isAacVariant && audioType) {
          const safariFallback = audioType === 'audio/mp4' ? 'audio/aac' : 'audio/mp4';
          if (!sourceTypes.includes(safariFallback)) {
            sourceTypes.push(safariFallback);
          }
        }
        if (sourceTypes.length === 0) {
          const sourceEl = document.createElement('source');
          sourceEl.src = src;
          audioEl.appendChild(sourceEl);
        } else {
          sourceTypes.forEach((type) => {
            const sourceEl = document.createElement('source');
            sourceEl.src = src;
            sourceEl.type = type;
            audioEl.appendChild(sourceEl);
          });
        }
        return audioEl;
      }

      function parseMessageOptions(rawOptions) {
        if (!rawOptions) return [];
        let parsed = rawOptions;
        if (typeof rawOptions === 'string') {
          const trimmed = rawOptions.trim();
          if (!trimmed) return [];
          try {
            parsed = JSON.parse(trimmed);
          } catch (err) {
            return [];
          }
        }
        if (!Array.isArray(parsed)) return [];
        const options = [];
        parsed.forEach(option => {
          if (!option || typeof option !== 'object') return;
          const reply = option.reply && typeof option.reply === 'object' ? option.reply : {};
          const title = option.title || option.text || option.label || reply.title;
          const url = option.url || option.link;
          const payload = option.payload || option.PAYLOAD || option.id || reply.id || option.phone_number || option.phone;
          const type = option.type || '';
          if (title) {
            const detail = url || payload ? `${type ? `${type}: ` : ''}${url || payload}` : type;
            options.push({ label: title, detail });
          } else if (url || payload) {
            options.push({ label: String(url || payload), detail: type });
          }
        });
        return options;
      }
      const sendBtn = document.getElementById('sendBtn');
      const messageInput = document.getElementById('messageInput');
      const inputArea = document.querySelector('.inputArea');
      const imagePreviewChip = document.getElementById('imagePreviewChip');
      const imagePreviewThumb = document.getElementById('imagePreviewThumb');
      const videoPreviewChip = document.getElementById('videoPreviewChip');
      const videoPreviewThumb = document.getElementById('videoPreviewThumb');
      let autocorrectTimeout = null;
      let autocorrectController = null;
      let lastAutocorrectedText = '';
      function scheduleAutocorrect(delayOverride) {
        if (!messageInput || !autocorrectEnabled) return;
        const currentText = messageInput.value;
        if (!currentText || !currentText.trim()) return;
        if (currentText === lastAutocorrectedText) return;
        if (autocorrectTimeout) clearTimeout(autocorrectTimeout);
        const delay = typeof delayOverride === 'number' ? delayOverride : 800;
        autocorrectTimeout = setTimeout(() => {
          autocorrectTimeout = null;
          runAutocorrect();
        }, delay);
      }
      async function runAutocorrect() {
        if (!messageInput || !autocorrectEnabled) return;
        const originalText = messageInput.value;
        if (!originalText || !originalText.trim()) return;
        if (autocorrectController) {
          autocorrectController.abort();
        }
        autocorrectController = new AbortController();
        try {
          const response = await fetch('/autocorrect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: originalText }),
            signal: autocorrectController.signal
          });
          if (!response.ok) return;
          const data = await response.json();
          const correctedText = data?.text;
          if (!correctedText || typeof correctedText !== 'string') return;
          if (messageInput.value !== originalText) return;
          if (correctedText !== originalText) {
            messageInput.value = correctedText;
            messageInput.setSelectionRange(correctedText.length, correctedText.length);
          }
          lastAutocorrectedText = messageInput.value;
        } catch (err) {
          if (err.name !== 'AbortError') {
            console.error('Error autocorrigiendo el texto', err);
          }
        }
      }
      const clearImageDraftBtn = document.getElementById('clearImageDraft');
      const clearVideoDraftBtn = document.getElementById('clearVideoDraft');
      if (imagePreviewChip) {
        imagePreviewChip.hidden = true;
      }
      if (imagePreviewThumb) {
        imagePreviewThumb.removeAttribute('src');
      }
      if (videoPreviewChip) {
        videoPreviewChip.hidden = true;
      }
      if (videoPreviewThumb) {
        videoPreviewThumb.removeAttribute('src');
      }
      const sidebar = document.querySelector('.sidebar');
      const menuToggle = document.getElementById('menuToggle');
      const mobileBackBtn = document.getElementById('mobileBackBtn');
      const mobileChatTitle = document.getElementById('mobileChatTitle');
      const mobileChatSubtitle = document.getElementById('mobileChatSubtitle');
      const mobileChatAvatar = document.getElementById('mobileChatAvatar');
      const mobileChatActions = document.getElementById('mobileChatActions');
      const bodyEl = document.body;
      function updateMobileSidebarState(shouldShowSidebar) {
        if (shouldShowSidebar) {
          sidebar.classList.add('visible');
          bodyEl.classList.add('mobile-sidebar-open');
        } else {
          sidebar.classList.remove('visible');
          bodyEl.classList.remove('mobile-sidebar-open');
        }
      }

      function syncMobileLayout() {
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        if (!isMobile) {
          bodyEl.classList.remove('mobile-sidebar-open');
          sidebar.classList.remove('visible');
          return;
        }
        updateMobileSidebarState(!currentChat);
      }

      menuToggle.addEventListener('click', () => {
        const shouldOpen = !bodyEl.classList.contains('mobile-sidebar-open');
        updateMobileSidebarState(shouldOpen);
      });
      if (mobileBackBtn) {
        mobileBackBtn.addEventListener('click', () => {
          updateMobileSidebarState(true);
        });
      }

      if (mobileChatActions) {
        mobileChatActions.addEventListener('click', event => {
          event.stopPropagation();
          if (!currentChat) return;
          const chatData = todosChats.find(c => c.numero === currentChat);
          if (!chatData) return;
          const rect = mobileChatActions.getBoundingClientRect();
          const coords = {
            pageX: rect.right - 8 + window.scrollX,
            pageY: rect.bottom + 8 + window.scrollY
          };
          openChatContextMenu(coords, chatData);
        });
      }
      if (mobileChatAvatar) {
        mobileChatAvatar.addEventListener('click', () => {
          if (mobileChatAvatar.hidden || !mobileChatAvatar.src) return;
          openImageModal(mobileChatAvatar.src, mobileChatAvatar.alt || 'Foto de perfil');
        });
      }

      const COLLAPSED_ICON = '‚ñ∂';
      const EXPANDED_ICON = '‚ñº';
      updateMobileChatHeader(null);
      syncMobileLayout();

      function openImageModal(src, altText = 'Imagen del mensaje') {
        if (!src) return;
        imageModalImg.src = src;
        imageModalImg.alt = altText;
        imageModalEl.classList.add('show');
        imageModalEl.setAttribute('aria-hidden', 'false');
      }

      function closeImageModal() {
        imageModalEl.classList.remove('show');
        imageModalEl.setAttribute('aria-hidden', 'true');
        imageModalImg.src = '';
        imageModalImg.alt = 'Imagen del mensaje';
      }

      if (imageModalCloseBtn) {
        imageModalCloseBtn.addEventListener('click', closeImageModal);
      }

      imageModalEl.addEventListener('click', event => {
        if (event.target === imageModalEl) {
          closeImageModal();
        }
      });

      document.addEventListener('keydown', event => {
        if (event.key === 'Escape' && imageModalEl.classList.contains('show')) {
          closeImageModal();
        }
      });

      chatBoxEl.addEventListener('click', event => {
        const target = event.target;
        if (target instanceof HTMLImageElement && target.classList.contains('chat-image')) {
          openImageModal(target.src, target.alt || 'Imagen del mensaje');
        }
      });

      function setSectionExpanded(section, expanded) {
        if (!section) return;
        section.classList.toggle('expanded', expanded);
        section.classList.toggle('collapsed', !expanded);
        const icon = section.querySelector('.menu-header-icon');
        if (icon) icon.textContent = expanded ? EXPANDED_ICON : COLLAPSED_ICON;
      }

      function toggleSectionByHeader(header) {
        if (!header) return;
        const section = header.closest('.menu-section');
        if (!section) return;
        const isExpanded = section.classList.contains('expanded');
        setSectionExpanded(section, !isExpanded);
      }

      chatContextMenu.querySelectorAll('.menu-header.collapsible').forEach(header => {
        header.addEventListener('click', e => {
          e.stopPropagation();
          toggleSectionByHeader(header);
        });
      });

      window.addEventListener('resize', syncMobileLayout);

      setSectionExpanded(chatStateSection, false);
      setSectionExpanded(chatRolesSection, false);
      setSectionExpanded(chatUsersSection, false);
      function injectChatStateStyles(definitions) {
        if (!Array.isArray(definitions) || definitions.length === 0) {
          const existing = document.getElementById('chat-state-dynamic-styles');
          if (existing) existing.remove();
          return;
        }

        const styleId = 'chat-state-dynamic-styles';
        let styleEl = document.getElementById(styleId);
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }

        const rules = [];
        definitions.forEach(def => {
          if (!def || !def.key) return;
          const bg = def.color || '#666666';
          const text = def.text_color || '#ffffff';
          const key = def.key;
          rules.push(`#chatList li.estado-${key} { background-color: ${bg}; color: ${text}; }`);
          rules.push(`#chatList li.estado-${key}:hover { background-color: ${bg}; color: ${text}; }`);
          rules.push(`#chatList li.estado-${key} .badge { background: rgba(0, 0, 0, 0.18); color: ${text}; }`);
        });
        styleEl.textContent = rules.join('\n');
      }

      function rebuildChatStateOptions() {
        chatStateOptionsContainer.innerHTML = '';

        if (Array.isArray(chatStateDefinitions) && chatStateDefinitions.length) {
          chatStateDefinitions.forEach(def => {
            if (!def || !def.key) return;
            if (def.visible === false) return;
            const option = document.createElement('div');
            option.className = 'context-option';
            option.dataset.estado = def.key;

            if (def.color) {
              const colorDot = document.createElement('span');
              colorDot.className = 'state-color-dot';
              colorDot.style.backgroundColor = def.color;
              option.appendChild(colorDot);
            }

            const label = document.createElement('span');
            label.textContent = def.label || def.key;
            option.appendChild(label);

            chatStateOptionsContainer.appendChild(option);
          });
        }

        const clearOption = document.createElement('div');
        clearOption.className = 'context-option';
        clearOption.dataset.estado = '';
        clearOption.textContent = 'Sin estado';
        chatStateOptionsContainer.appendChild(clearOption);

        chatStateOptions = Array.from(chatStateOptionsContainer.querySelectorAll('[data-estado]'));
        chatStateOptions.forEach(option => {
          option.addEventListener('click', () => {
            if (!chatContextTarget) return;
            const chatData = chatContextTarget;
            const estado = option.dataset.estado || null;
            hideChatContextMenu();
            updateChatState(chatData.numero, estado)
              .then(() => fetchChatList())
              .catch(err => console.error(err));
          });
        });
      }

      injectChatStateStyles(chatStateDefinitions);
      rebuildChatStateOptions();
        const lastChatTimestamps = {};
        const predefinedRoleIcons = { ventas: 'üíº', soporte: 'üõ†', marketing: 'üì£' };

        function computeRoleAbbreviation(source) {
          if (!source || typeof source !== 'string') return '';
          const normalized = source.trim();
          if (!normalized) return '';
          const parts = normalized.split(/[\s_\-]+/).filter(Boolean);
          if (!parts.length) return normalized.slice(0, 2).toUpperCase();
          const abbreviation = parts.map(part => part.charAt(0).toUpperCase()).join('');
          if (abbreviation.length >= 2) return abbreviation;
          const firstPart = parts[0];
          return (firstPart.slice(0, 2).toUpperCase()) || abbreviation || normalized.charAt(0).toUpperCase();
        }

        function buildRoleBadgeMap(roles) {
          const map = {};
          if (!Array.isArray(roles)) return map;
          roles.forEach(roleEntry => {
            if (!roleEntry) return;
            const [id, name, keyword] = roleEntry;
            const key = keyword || name;
            if (!key) return;
            if (predefinedRoleIcons[key]) {
              map[key] = predefinedRoleIcons[key];
              return;
            }
            const source = name || key;
            const abbreviation = computeRoleAbbreviation(source);
            map[key] = abbreviation || key.charAt(0).toUpperCase();
          });
          return map;
        }

        const roleIcons = buildRoleBadgeMap(availableRoles);

        function getRoleBadge(keyword) {
          if (!keyword) return '';
          if (predefinedRoleIcons[keyword]) return predefinedRoleIcons[keyword];
          if (roleIcons[keyword]) return roleIcons[keyword];
          return computeRoleAbbreviation(keyword) || keyword.charAt(0).toUpperCase();
        }

        function toggleFilterPanel() {
          if (!filterPanel || !filterToggle) return;
          const isExpanded = filterToggle.getAttribute('aria-expanded') === 'true';
          const next = !isExpanded;
          filterToggle.setAttribute('aria-expanded', String(next));
          filterPanel.hidden = !next;
        }

        if (filterToggle && filterPanel) {
          filterToggle.setAttribute('aria-expanded', 'false');
          filterPanel.hidden = true;
        }

        buildFilterOptions();
        if (filterToggle && filterPanel) {
          filterToggle.addEventListener('click', toggleFilterPanel);
        }

        if (filterStateSelect) {
          filterStateSelect.addEventListener('change', () => {
            if (filterShowInactive && filterStateSelect.value === 'inactivo') {
              filterShowInactive.checked = true;
            }
            applyChatFilters();
          });
        }
        [filterRoleSelect, filterUserSelect, filterIntegrationSelect, filterDateFrom, filterDateTo].forEach(el => {
          if (!el) return;
          el.addEventListener('change', applyChatFilters);
        });
        if (filterShowInactive) {
          filterShowInactive.addEventListener('change', applyChatFilters);
        }

        const CHAT_SOURCE_LOGOS = {
          instagram: "{{ url_for('static', filename='logo-instagram.png') }}",
          facebook: "{{ url_for('static', filename='logo-facebook.png') }}",
          messenger: "{{ url_for('static', filename='logo-facebook.png') }}",
          whatsapp: "{{ url_for('static', filename='logo-whatsapp.png') }}"
        };

        function resolveChatSourceLogo(linkUrl) {
          const value = (linkUrl || '').toString().toLowerCase();
          if (value === 'instagram' || value.includes('instagram.com') || value.includes('instagr.am')) {
            return { key: 'instagram', label: 'Instagram' };
          }
          if (value.includes('messenger.com') || value.includes('m.me') || value === 'messenger') {
            return { key: 'messenger', label: 'Messenger' };
          }
          if (value.includes('facebook.com') || value.includes('fb.com') || value.includes('fb.me')) {
            return { key: 'facebook', label: 'Facebook' };
          }
          return { key: 'whatsapp', label: 'WhatsApp' };
        }

        function appendSelectOption(select, value, label) {
          if (!select) return;
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          select.appendChild(option);
        }

        function buildFilterOptions() {
          if (filterStateSelect) {
            filterStateSelect.innerHTML = '';
            appendSelectOption(filterStateSelect, '', 'Todos');
            chatStateDefinitions.forEach(def => {
              if (!def || !def.key) return;
              if (def.visible === false) return;
              const label = def.label || def.key;
              appendSelectOption(filterStateSelect, def.key, label);
            });
          }
          if (filterRoleSelect) {
            filterRoleSelect.innerHTML = '';
            appendSelectOption(filterRoleSelect, '', 'Todos');
            availableRoles.forEach(roleEntry => {
              if (!roleEntry || roleEntry.length < 3) return;
              const roleName = roleEntry[1] || roleEntry[2];
              const roleKeyword = roleEntry[2];
              appendSelectOption(filterRoleSelect, roleKeyword, roleName);
            });
          }
          if (filterUserSelect) {
            filterUserSelect.innerHTML = '';
            appendSelectOption(filterUserSelect, '', 'Todos');
            availableUsers.forEach(userEntry => {
              if (!userEntry || userEntry.length < 2) return;
              const userId = userEntry[0];
              const displayName = userEntry[1] || userEntry[2] || userId;
              appendSelectOption(filterUserSelect, String(userId), displayName);
            });
          }
        }

        function applyChatFilters() {
          const stateFilter = filterStateSelect ? filterStateSelect.value : '';
          const roleFilter = filterRoleSelect ? filterRoleSelect.value : '';
          const userFilter = filterUserSelect ? filterUserSelect.value : '';
          const integrationFilter = filterIntegrationSelect ? filterIntegrationSelect.value : '';
          const showInactive = Boolean(filterShowInactive && filterShowInactive.checked) || stateFilter === 'inactivo';
          const fromValue = filterDateFrom ? filterDateFrom.value : '';
          const toValue = filterDateTo ? filterDateTo.value : '';
          const fromDate = fromValue ? new Date(`${fromValue}T00:00:00`) : null;
          const toDate = toValue ? new Date(`${toValue}T23:59:59`) : null;

          const filtered = (todosChats || []).filter(chat => {
            if (!showInactive && chat.estado === 'inactivo') return false;
            if (stateFilter && chat.estado !== stateFilter) return false;
            if (roleFilter && (!Array.isArray(chat.roles_kw) || !chat.roles_kw.includes(roleFilter))) return false;
            if (userFilter && String(chat.assigned_user_id || '') !== userFilter) return false;
            if (integrationFilter) {
              const sourceKey = resolveChatSourceLogo(chat.first_link_url).key;
              if (sourceKey !== integrationFilter) return false;
            }
            if (fromDate || toDate) {
              if (!chat.last_timestamp) return false;
              const chatDate = new Date(chat.last_timestamp);
              if (Number.isNaN(chatDate.getTime())) return false;
              if (fromDate && chatDate < fromDate) return false;
              if (toDate && chatDate > toDate) return false;
            }
            return true;
          });

          renderChatList(filtered);
        }
        let isSending = false;
        let isSendingImage = false;
        let isSendingAudio = false;
        let isSendingVideo = false;
        let isRecordingAudio = false;
        let imageDraft = null;
        let videoDraft = null;
        let isBotoneraSending = false;
        let sendUnlockTimeout = null;
        let lastSentMessage = '';
        let lastSentTimestamp = 0;
        const pendingVideoUploads = new Map();
        const audioStatusEl = document.getElementById('audioStatus');
        let audioStatusTimeout = null;
        const videoStatusEl = document.getElementById('videoStatus');
        let videoStatusTimeout = null;

        function startSending() {
          if (sendUnlockTimeout) clearTimeout(sendUnlockTimeout);
          isSending = true;
          updateSendButtons();
          sendUnlockTimeout = setTimeout(() => {
            stopSending();
          }, 8000);
        }

        function stopSending() {
          if (sendUnlockTimeout) {
            clearTimeout(sendUnlockTimeout);
            sendUnlockTimeout = null;
          }
          isSending = false;
          updateSendButtons();
        }

        function updateSendButtons() {
          if (sendBtn) {
            sendBtn.disabled = isSending || isSendingImage || isSendingAudio || isRecordingAudio;
          }
        }

        function buildPendingVideoElement(pending) {
          const div = document.createElement('div');
          div.className = 'bubble asesor message pending-message';
          div.dataset.pendingId = pending.id;

          if (pending.previewUrl) {
            const v = document.createElement('video');
            v.controls = true;
            v.muted = true;
            v.playsInline = true;
            v.src = pending.previewUrl;
            v.style.maxWidth = '200px';
            div.appendChild(v);
          }

          if (pending.caption) {
            const p = document.createElement('p');
            p.textContent = pending.caption;
            div.appendChild(p);
          }

          const status = document.createElement('div');
          status.className = 'pending-status';
          status.dataset.state = pending.state || 'uploading';

          const spinner = document.createElement('span');
          spinner.className = 'pending-spinner';

          const text = document.createElement('span');
          text.className = 'pending-text';
          text.textContent = pending.message || 'Enviando video‚Ä¶';

          status.appendChild(spinner);
          status.appendChild(text);
          div.appendChild(status);
          return div;
        }

        function addPendingVideoUpload({ file, previewUrl, caption }) {
          if (!currentChat) return null;
          const id = `pending-video-${Date.now()}-${Math.random().toString(16).slice(2)}`;
          const pendingUrl = previewUrl || (file ? URL.createObjectURL(file) : '');
          const payload = {
            id,
            chat: currentChat,
            previewUrl: pendingUrl,
            caption: caption || '',
            state: 'uploading',
            message: 'Enviando video‚Ä¶',
            createdAt: Date.now()
          };
          pendingVideoUploads.set(id, payload);
          if (chatBoxEl) {
            const el = buildPendingVideoElement(payload);
            chatBoxEl.appendChild(el);
            scrollChatToBottom();
          }
          return id;
        }

        function updatePendingVideoUpload(id, { state, message } = {}) {
          const pending = pendingVideoUploads.get(id);
          if (!pending) return;
          if (state) pending.state = state;
          if (message) pending.message = message;
          const el = chatBoxEl ? chatBoxEl.querySelector(`[data-pending-id="${id}"]`) : null;
          if (!el) return;
          const status = el.querySelector('.pending-status');
          if (!status) return;
          if (pending.state) status.dataset.state = pending.state;
          const text = status.querySelector('.pending-text');
          if (text && pending.message) text.textContent = pending.message;
        }

        function removePendingVideoUpload(id) {
          const pending = pendingVideoUploads.get(id);
          if (!pending) return;
          if (pending.previewUrl) {
            URL.revokeObjectURL(pending.previewUrl);
          }
          pendingVideoUploads.delete(id);
          const el = chatBoxEl ? chatBoxEl.querySelector(`[data-pending-id="${id}"]`) : null;
          if (el) el.remove();
        }

        function appendPendingVideoUploads(fragment) {
          if (!pendingVideoUploads.size) return;
          pendingVideoUploads.forEach(pending => {
            if (pending.chat !== currentChat) return;
            fragment.appendChild(buildPendingVideoElement(pending));
          });
        }

        function reconcilePendingVideoUploads(msgs) {
          if (!pendingVideoUploads.size || !Array.isArray(msgs)) return;
          const candidates = [];
          msgs.forEach(row => {
            if (!Array.isArray(row)) return;
            const [txt, tipo, url, opciones, ts] = row;
            if (!tipo || !tipo.startsWith('asesor')) return;
            if (!tipo.includes('video')) return;
            const timestamp = ts ? Date.parse(ts) : null;
            candidates.push({
              timestamp,
              text: (txt || '').trim()
            });
          });
          const usedIndexes = new Set();
          pendingVideoUploads.forEach(pending => {
            if (pending.chat !== currentChat) return;
            if (pending.state === 'error') return;
            for (let i = 0; i < candidates.length; i += 1) {
              if (usedIndexes.has(i)) continue;
              const candidate = candidates[i];
              if (candidate.timestamp === null) continue;
              if (pending.caption && candidate.text && candidate.text !== pending.caption.trim()) {
                continue;
              }
              if (candidate.timestamp + 5000 < pending.createdAt) {
                continue;
              }
              usedIndexes.add(i);
              removePendingVideoUpload(pending.id);
              break;
            }
          });
        }

        function setAudioStatus(message, state = 'info', autoClearMs = 0) {
          if (!audioStatusEl) return;
          if (audioStatusTimeout) {
            clearTimeout(audioStatusTimeout);
            audioStatusTimeout = null;
          }
          audioStatusEl.textContent = message || '';
          audioStatusEl.dataset.state = state || 'info';
          audioStatusEl.hidden = !message;
          if (message && autoClearMs) {
            audioStatusTimeout = setTimeout(() => {
              audioStatusEl.textContent = '';
              audioStatusEl.hidden = true;
              audioStatusTimeout = null;
            }, autoClearMs);
          }
        }

        function setVideoStatus(message, state = 'info', autoClearMs = 0) {
          if (!videoStatusEl) return;
          if (videoStatusTimeout) {
            clearTimeout(videoStatusTimeout);
            videoStatusTimeout = null;
          }
          videoStatusEl.textContent = message || '';
          videoStatusEl.dataset.state = state || 'info';
          videoStatusEl.hidden = !message;
          if (message && autoClearMs) {
            videoStatusTimeout = setTimeout(() => {
              videoStatusEl.textContent = '';
              videoStatusEl.hidden = true;
              videoStatusTimeout = null;
            }, autoClearMs);
          }
        }

        const FLOW_SUMMARY_MAX_ITEMS = 10;
        const EXCLUDED_FLOW_KEYS = new Set(['flow_token']);

        function isExcludedFlowKey(key) {
          return typeof key === 'string' && EXCLUDED_FLOW_KEYS.has(key.toLowerCase());
        }

        function isEmptyFlowValue(value) {
          if (value === null || value === undefined) {
            return true;
          }
          if (typeof value === 'string') {
            return value.trim().length === 0;
          }
          if (Array.isArray(value)) {
            return value.every(item => isEmptyFlowValue(item));
          }
          if (typeof value === 'object') {
            return Object.values(value).every(item => isEmptyFlowValue(item));
          }
          return false;
        }

        function createFlowSummarySection(summaryItems) {
          if (!Array.isArray(summaryItems) || !summaryItems.length) {
            return null;
          }

          const container = document.createElement('div');
          container.className = 'flow-summary-section';
          const list = document.createElement('ul');
          list.className = 'flow-summary';
          container.appendChild(list);

          const hasMore = summaryItems.length > FLOW_SUMMARY_MAX_ITEMS;
          let expanded = false;

          const renderItems = () => {
            list.innerHTML = '';
            const items = expanded ? summaryItems : summaryItems.slice(0, FLOW_SUMMARY_MAX_ITEMS);
            items.forEach(item => {
              if (!item) return;
              const li = document.createElement('li');
              li.className = 'flow-summary-item';
              const key = document.createElement('span');
              key.className = 'flow-summary-key';
              key.textContent = item.label;
              const value = document.createElement('span');
              value.className = 'flow-summary-value';
              value.textContent = item.value;
              li.appendChild(key);
              li.appendChild(value);
              list.appendChild(li);
            });
          };

          renderItems();

          if (hasMore) {
            const remaining = summaryItems.length - FLOW_SUMMARY_MAX_ITEMS;
            const toggle = document.createElement('button');
            toggle.type = 'button';
            toggle.className = 'flow-summary-more';
            toggle.setAttribute('aria-expanded', 'false');

            const updateToggleLabel = () => {
              toggle.textContent = expanded
                ? 'Mostrar menos'
                : `+ ${remaining} dato${remaining !== 1 ? 's' : ''} adicional${remaining !== 1 ? 'es' : ''}`;
            };

            updateToggleLabel();

            toggle.addEventListener('click', () => {
              expanded = !expanded;
              renderItems();
              toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
              updateToggleLabel();
            });

            container.appendChild(toggle);
          }

          return container;
        }

        function normalizeFlowNode(value) {
          if (Array.isArray(value)) {
            const normalized = [];
            value.forEach(item => {
              const normalizedItem = normalizeFlowNode(item);
              if (!isEmptyFlowValue(normalizedItem)) {
                normalized.push(normalizedItem);
              }
            });
            return normalized;
          }
          if (value && typeof value === 'object') {
            const normalized = {};
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const normalizedValue = normalizeFlowNode(val);
              if (!isEmptyFlowValue(normalizedValue)) {
                normalized[String(key)] = normalizedValue;
              }
            });
            return normalized;
          }
          return value;
        }

        function formatFlowValue(value) {
          if (value === null || value === undefined) {
            return '‚Äî';
          }
          if (typeof value === 'boolean') {
            return value ? 'S√≠' : 'No';
          }
          if (typeof value === 'number') {
            return String(value);
          }
          if (typeof value === 'string') {
            const text = value.trim();
            return text.length ? text : '‚Äî';
          }
          return String(value);
        }

        function flattenFlowData(value, prefix = []) {
          if (Array.isArray(value) || (value && typeof value === 'object')) {
            value = normalizeFlowNode(value);
          }
          const items = [];
          if (Array.isArray(value)) {
            value.forEach((item, idx) => {
              const label = prefix.length ? `Elemento ${idx + 1}` : `Respuesta ${idx + 1}`;
              const nextPrefix = prefix.concat(label);
              if (item && typeof item === 'object') {
                const nested = flattenFlowData(item, nextPrefix);
                if (nested.length) {
                  items.push(...nested);
                }
              } else {
                items.push({
                  label: nextPrefix.join(' ‚Ä∫ '),
                  value: formatFlowValue(item),
                });
              }
            });
            return items;
          }
          if (value && typeof value === 'object') {
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const nested = flattenFlowData(val, prefix.concat(String(key)));
              if (nested.length) {
                items.push(...nested);
              }
            });
            return items;
          }
          const label = prefix.length ? prefix.join(' ‚Ä∫ ') : 'Respuesta';
          items.push({ label, value: formatFlowValue(value) });
          return items;
        }

        function buildFlowValueNode(value) {
          if (Array.isArray(value) || (value && typeof value === 'object')) {
            value = normalizeFlowNode(value);
          }
          if (Array.isArray(value)) {
            const list = document.createElement('ol');
            list.className = 'flow-data-list flow-data-array';
            value.forEach(item => {
              const node = buildFlowValueNode(item);
              if (!node) {
                return;
              }
              const li = document.createElement('li');
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(node);
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list.children.length ? list : null;
          }
          if (value && typeof value === 'object') {
            const list = document.createElement('ul');
            list.className = 'flow-data-list flow-data-object';
            Object.entries(value).forEach(([key, val]) => {
              if (isExcludedFlowKey(key)) {
                return;
              }
              const node = buildFlowValueNode(val);
              if (!node) {
                return;
              }
              const li = document.createElement('li');
              const keySpan = document.createElement('span');
              keySpan.className = 'flow-key';
              keySpan.textContent = key;
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(node);
              li.appendChild(keySpan);
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list.children.length ? list : null;
          }
          const span = document.createElement('span');
          span.className = 'flow-value';
          span.textContent = formatFlowValue(value);
          return span;
        }

        function createFlowCard(flowName, flowJson) {
          const name = typeof flowName === 'string' ? flowName.trim() : '';
          let parsed = null;

          if (flowJson === null || flowJson === undefined) {
            parsed = null;
          } else if (typeof flowJson === 'string') {
            const raw = flowJson.trim();
            if (raw) {
              try {
                parsed = JSON.parse(raw);
              } catch (err) {
                parsed = raw;
              }
            } else {
              parsed = '';
            }
          } else if (typeof flowJson === 'object') {
            parsed = flowJson;
          } else {
            const raw = String(flowJson).trim();
            parsed = raw;
          }

          if (parsed && typeof parsed === 'object') {
            parsed = normalizeFlowNode(parsed);
          }

          const hasRawContent = parsed !== null && parsed !== undefined;
          let hasContent = false;
          if (hasRawContent) {
            if (typeof parsed === 'string') {
              hasContent = parsed.trim().length > 0;
            } else if (Array.isArray(parsed)) {
              hasContent = parsed.length > 0;
            } else if (typeof parsed === 'object') {
              hasContent = Object.keys(parsed).length > 0;
            } else {
              hasContent = String(parsed).trim().length > 0;
            }
          }

          const hasName = name.length > 0;
          if (!hasName && !hasContent) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline';

          if (hasName) {
            const title = document.createElement('p');
            title.className = 'flow-text flow-name';
            title.textContent = name;
            card.appendChild(title);
          }

          let appendedContent = false;

          if (hasRawContent) {
            if (parsed && typeof parsed === 'object') {
              const summaryItems = flattenFlowData(parsed);
              if (summaryItems.length) {
                const summarySection = createFlowSummarySection(summaryItems);
                if (summarySection) {
                  card.appendChild(summarySection);
                  appendedContent = true;
                }
              } else {
                const isEmptyObject = parsed && !Array.isArray(parsed) && Object.keys(parsed).length === 0;
                const isEmptyArray = Array.isArray(parsed) && parsed.length === 0;
                if (isEmptyObject || isEmptyArray) {
                  const placeholder = document.createElement('p');
                  placeholder.className = 'flow-text';
                  placeholder.textContent = 'Sin contenido';
                  card.appendChild(placeholder);
                  appendedContent = true;
                } else {
                  const node = buildFlowValueNode(parsed);
                  if (node) {
                    card.appendChild(node);
                    appendedContent = true;
                  }
                }
              }
            } else if (typeof parsed === 'string') {
              const textValue = formatFlowValue(parsed);
              if (textValue && textValue !== '‚Äî') {
                const text = document.createElement('p');
                text.className = 'flow-text';
                text.textContent = textValue;
                card.appendChild(text);
                appendedContent = true;
              }
            } else {
              const text = document.createElement('p');
              text.className = 'flow-text';
              text.textContent = formatFlowValue(parsed);
              card.appendChild(text);
              appendedContent = true;
            }
          }

          if (!appendedContent && hasName) {
            const placeholder = document.createElement('p');
            placeholder.className = 'flow-text';
            placeholder.textContent = 'Sin contenido';
            card.appendChild(placeholder);
          }

          return card;
        }

        function createFlowSegmentsCard(segments, originalText) {
          if (!Array.isArray(segments) || !segments.length) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline flow-segments-card';

          let hasContent = false;
          let userLabelShown = false;

          segments.forEach(segment => {
            if (!segment || typeof segment !== 'object') {
              return;
            }

            if (segment.kind === 'text') {
              const content = (segment.content || '').trim();
              if (!content) {
                return;
              }
              const original = (originalText || '').trim();
              if (!userLabelShown && content === original && segments.length === 1) {
                return;
              }
              const p = document.createElement('p');
              p.className = 'flow-text';
              if (!userLabelShown) {
                const label = document.createElement('span');
                label.className = 'flow-label';
                label.textContent = 'Usuario:';
                p.appendChild(label);
                p.appendChild(document.createTextNode(' ' + content));
                userLabelShown = true;
              } else {
                p.textContent = content;
              }
              card.appendChild(p);
              hasContent = true;
              return;
            }

            if (segment.kind === 'data') {
              const content = Array.isArray(segment.content) || (segment.content && typeof segment.content === 'object')
                ? normalizeFlowNode(segment.content)
                : segment.content;
              if (isEmptyFlowValue(content)) {
                return;
              }
              const summary = Array.isArray(segment.summary)
                ? segment.summary.filter(item => item && typeof item.label === 'string' && !item.label.toLowerCase().includes('flow_token'))
                : [];
              if (summary.length) {
                const summarySection = createFlowSummarySection(summary);
                if (summarySection) {
                  card.appendChild(summarySection);
                  hasContent = true;
                }
              } else if (segment.display) {
                const trimmed = segment.display.trim();
                if (!trimmed || trimmed === '{}' || trimmed === '[]') {
                  return;
                }
                const pre = document.createElement('pre');
                pre.className = 'flow-json';
                pre.textContent = trimmed;
                card.appendChild(pre);
                hasContent = true;
              } else if (content !== null && content !== undefined) {
                const p = document.createElement('p');
                p.className = 'flow-text';
                p.textContent = formatFlowValue(content);
                card.appendChild(p);
                hasContent = true;
              }
            }
          });

          return hasContent ? card : null;
        }

        function playAlertSound() {
          if (!notificationAudio || !notificationSoundEnabled) return;
          try {
            notificationAudio.currentTime = 0;
            const playPromise = notificationAudio.play();
            if (playPromise && typeof playPromise.catch === 'function') {
              playPromise.catch(err => {
                if (err && err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
                  console.error('No se pudo reproducir el sonido de notificaci√≥n', err);
                }
              });
            }
          } catch (err) {
            console.error('Error al reproducir el sonido de notificaci√≥n', err);
          }
        }

        async function extractSendError(response) {
          const fallbackMessage = 'No se pudo enviar el mensaje';
          if (!response) return fallbackMessage;
          try {
            const text = await response.text();
            const trimmed = (text || '').trim();
            if (!trimmed) return fallbackMessage;
            try {
              const data = JSON.parse(trimmed);
              if (data && data.error) return data.error;
            } catch (err) {
              return trimmed.length > 300 ? `${trimmed.slice(0, 297)}...` : trimmed;
            }
          } catch (err) {
            return fallbackMessage;
          }
          return fallbackMessage;
        }

      function addLongPressListener(element, callback) {
        let timer = null;
        let startX = 0;
        let startY = 0;
        const clearTimer = () => {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        };
        element.addEventListener('touchstart', event => {
          if (event.touches.length !== 1) return;
          const touch = event.touches[0];
          startX = touch.clientX;
          startY = touch.clientY;
          timer = setTimeout(() => {
            timer = null;
            callback(event);
          }, 550);
        }, { passive: true });
        element.addEventListener('touchmove', event => {
          if (!timer) return;
          const touch = event.touches[0];
          if (Math.abs(touch.clientX - startX) > 10 || Math.abs(touch.clientY - startY) > 10) {
            clearTimer();
          }
        }, { passive: true });
        element.addEventListener('touchend', clearTimer);
        element.addEventListener('touchcancel', clearTimer);
      }

      function openReplyMenuAt(pageX, pageY, bubble) {
        if (!bubble) return;
        selectedBubble = bubble;
        contextMenu.style.top = `${pageY}px`;
        contextMenu.style.left = `${pageX}px`;
        contextMenu.classList.add('show');
      }

      document.addEventListener('click', () => contextMenu.classList.remove('show'));

      replyAction.onclick = () => {
        if (!selectedBubble) return;
        replyTo = selectedBubble.dataset.waId;
        replyPreviewEl.innerHTML = '';
        const tipo = selectedBubble.dataset.tipo || '';
        const url  = normalizeMediaUrl(selectedBubble.dataset.url);
        const text = selectedBubble.dataset.text;
        if (url && tipo.endsWith('_image')) {
          const img = document.createElement('img');
          img.src = url;
          img.alt = text || 'Imagen del mensaje';
          img.classList.add('chat-image');
          replyPreviewEl.appendChild(img);
        } else if (url && tipo.includes('audio')) {
          const a = createAudioElement(url);
          replyPreviewEl.appendChild(a);
        } else if (url && tipo.includes('video')) {
          const v = document.createElement('video'); v.controls=true; v.src=url; replyPreviewEl.appendChild(v);
        }
        if (text) {
          const p = document.createElement('p'); p.textContent = text; replyPreviewEl.appendChild(p);
        }
        replyPreviewEl.style.display = 'block';
        contextMenu.classList.remove('show');
      };

      replyPreviewEl.addEventListener('click', event => {
        const target = event.target;
        if (target instanceof HTMLImageElement && target.classList.contains('chat-image')) {
          openImageModal(target.src, target.alt || 'Imagen del mensaje');
          event.stopPropagation();
          return;
        }
        replyTo = null;
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
      });

      // Mostrar u ocultar men√∫ settings
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsMenu = document.getElementById('settingsMenu');
      settingsBtn.onclick = e => {
        e.stopPropagation();
        settingsMenu.classList.toggle('show');
      };
      function hideChatContextMenu() {
        chatContextMenu.classList.remove('show');
        chatContextMenu.style.visibility = '';
        chatContextTarget = null;
      }

      function openChatContextMenu(event, chatData) {
        chatContextTarget = chatData;
        const baseX = typeof event.clientX === 'number'
          ? event.clientX
          : (typeof event.pageX === 'number' ? event.pageX : (typeof event.x === 'number' ? event.x : 0));
        const baseY = typeof event.clientY === 'number'
          ? event.clientY
          : (typeof event.pageY === 'number' ? event.pageY : (typeof event.y === 'number' ? event.y : 0));
        chatContextMenu.style.visibility = 'hidden';
        chatContextMenu.classList.add('show');
        chatContextMenu.style.left = `${baseX}px`;
        chatContextMenu.style.top = `${baseY}px`;
        const rect = chatContextMenu.getBoundingClientRect();
        const margin = 8;
        let left = baseX;
        let top = baseY;
        if (rect.right > window.innerWidth - margin) {
          left = Math.max(margin, window.innerWidth - rect.width - margin);
        }
        if (rect.bottom > window.innerHeight - margin) {
          top = Math.max(margin, window.innerHeight - rect.height - margin);
        }
        if (rect.top < margin) {
          top = margin;
        }
        chatContextMenu.style.left = `${left}px`;
        chatContextMenu.style.top = `${top}px`;
        chatContextMenu.style.visibility = 'visible';
        setSectionExpanded(chatStateSection, false);
        setSectionExpanded(chatRolesSection, false);
        setSectionExpanded(chatUsersSection, false);
        buildChatRoleOptions(chatData);
        buildChatUserOptions(chatData);
      }

      function buildChatRoleOptions(chatData) {
        if (!chatRoleOptionsContainer) return;
        chatRoleOptionsContainer.innerHTML = '';

        if (!Array.isArray(availableRoles) || availableRoles.length === 0) {
          const emptyOption = document.createElement('div');
          emptyOption.className = 'context-option disabled role-option';
          emptyOption.textContent = 'Sin roles disponibles';
          chatRoleOptionsContainer.appendChild(emptyOption);
          return;
        }

        const assigned = Array.isArray(chatData.roles_kw) ? chatData.roles_kw : [];

        availableRoles.forEach(roleEntry => {
          if (!roleEntry || roleEntry.length < 3) return;
          const roleName = roleEntry[1] || roleEntry[2];
          const roleKeyword = roleEntry[2];
          const option = document.createElement('div');
          option.classList.add('context-option', 'role-option');
          option.dataset.role = roleKeyword;

          const label = document.createElement('span');
          label.className = 'role-option-label';
          label.textContent = roleName;
          option.appendChild(label);

          const hasRole = assigned.includes(roleKeyword);
          if (hasRole) {
            option.classList.add('active');
            const check = document.createElement('span');
            check.className = 'role-option-check';
            check.textContent = '‚úî';
            option.appendChild(check);
          }

          option.addEventListener('click', () => {
            toggleChatRole(chatData.numero, roleKeyword, hasRole);
          });

          chatRoleOptionsContainer.appendChild(option);
        });
      }

      function buildChatUserOptions(chatData) {
        if (!chatUserOptionsContainer) return;
        chatUserOptionsContainer.innerHTML = '';

        if (!Array.isArray(availableUsers) || availableUsers.length === 0) {
          const emptyOption = document.createElement('div');
          emptyOption.className = 'context-option disabled role-option';
          emptyOption.textContent = 'Sin usuarios disponibles';
          chatUserOptionsContainer.appendChild(emptyOption);
          return;
        }

        const assignedUserId = chatData.assigned_user_id || null;

        const clearOption = document.createElement('div');
        clearOption.classList.add('context-option', 'role-option');
        clearOption.dataset.user = '';
        clearOption.textContent = 'Sin asignaci√≥n';
        if (!assignedUserId) {
          clearOption.classList.add('active');
          const check = document.createElement('span');
          check.className = 'role-option-check';
          check.textContent = '‚úî';
          clearOption.appendChild(check);
        }
        clearOption.addEventListener('click', () => {
          assignChatUser(chatData.numero, null, Boolean(assignedUserId));
        });
        chatUserOptionsContainer.appendChild(clearOption);

        availableUsers.forEach(userEntry => {
          if (!userEntry || userEntry.length < 2) return;
          const userId = userEntry[0];
          const displayName = userEntry[1] || userEntry[2] || userId;
          const roleLabel = userEntry[3] ? ` (${userEntry[3]})` : '';
          const option = document.createElement('div');
          option.classList.add('context-option', 'role-option');
          option.dataset.user = userId;

          const label = document.createElement('span');
          label.className = 'role-option-label';
          label.textContent = `${displayName}${roleLabel}`;
          option.appendChild(label);

          const isAssigned = assignedUserId === userId;
          if (isAssigned) {
            option.classList.add('active');
            const check = document.createElement('span');
            check.className = 'role-option-check';
            check.textContent = '‚úî';
            option.appendChild(check);
          }

          option.addEventListener('click', () => {
            assignChatUser(chatData.numero, userId, isAssigned);
          });

          chatUserOptionsContainer.appendChild(option);
        });
      }

      async function toggleChatRole(numero, roleKeyword, hasRole) {
        if (!numero || !roleKeyword) return;
        try {
          const res = await fetch('/assign_chat_role', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              numero,
              role: roleKeyword,
              action: hasRole ? 'remove' : 'add'
            })
          });
          if (!res.ok) throw new Error('No se pudo actualizar el rol');
          hideChatContextMenu();
          fetchChatList();
        } catch (err) {
          console.error(err);
        }
      }

      async function assignChatUser(numero, userId, isAssigned) {
        if (!numero) return;
        try {
          const res = await fetch('/assign_chat_user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              numero,
              user_id: userId,
              action: isAssigned ? 'remove' : 'assign'
            })
          });
          const payload = await res.json().catch(() => ({}));
          if (!res.ok) {
            const message = payload && payload.error ? payload.error : 'No se pudo actualizar el usuario';
            throw new Error(message);
          }
          hideChatContextMenu();
          fetchChatList();
        } catch (err) {
          console.error(err);
          alert(err.message || 'No se pudo actualizar el usuario');
        }
      }

      document.addEventListener('click', e => {
        if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
          settingsMenu.classList.remove('show');
        }
        if (chatContextMenu.classList.contains('show') && !chatContextMenu.contains(e.target)) {
          hideChatContextMenu();
        }
      });
      window.addEventListener('resize', hideChatContextMenu);
      chatContextMenu.addEventListener('contextmenu', e => e.preventDefault());


      chatAliasAction.addEventListener('click', () => {
        if (!chatContextTarget) return;
        const chatData = chatContextTarget;
        hideChatContextMenu();
        const nombre = prompt(`Asignar alias a: ${chatData.numero}`, chatData.alias || "");
        if (nombre === null) return;
        const trimmed = nombre.trim();
        if (!trimmed) return;
        fetch('/set_alias', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ numero: chatData.numero, nombre: trimmed })
        }).then(() => fetchChatList());
      });

      function resetActiveChatIfMatches(numero) {
        if (currentChat !== numero) return;
        currentChat = null;
        lastCount = 0;
        if (autoRefresh) {
          clearInterval(autoRefresh);
          autoRefresh = null;
        }
        chatBoxEl.innerHTML = '';
        botoneraEl.innerHTML = '';
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
        updateMobileChatHeader(null);
        syncMobileLayout();
      }

      function finalizeChat(numero) {
        if (!numero) return;
        fetch('/finalizar_chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ numero })
        })
        .then(resp => {
          if (!resp.ok) throw new Error('No se pudo finalizar el chat');
          resetActiveChatIfMatches(numero);
          fetchChatList();
        })
        .catch(err => console.error(err));
      }

      chatFinishAction.addEventListener('click', () => {
        if (!chatContextTarget) return;
        const chatData = chatContextTarget;
        hideChatContextMenu();
        finalizeChat(chatData.numero);
      });

      if (chatFinishButton) {
        chatFinishButton.addEventListener('click', () => {
          if (!currentChat) return;
          finalizeChat(currentChat);
        });
      }

      if (chatDeleteAction) {
        chatDeleteAction.addEventListener('click', () => {
          if (!chatContextTarget) return;
          const chatData = chatContextTarget;
          hideChatContextMenu();
          const confirmed = confirm(`¬øEliminar el chat ${chatData.numero}? Esta acci√≥n no se puede deshacer.`);
          if (!confirmed) return;
          fetch('/delete_chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ numero: chatData.numero })
          })
          .then(resp => {
            if (!resp.ok) throw new Error('No se pudo eliminar el chat');
            resetActiveChatIfMatches(chatData.numero);
            fetchChatList();
          })
          .catch(err => console.error(err));
        });
      }

      function updateChatState(numero, estado) {
        const payload = { numero };
        payload.estado = estado ? estado : null;
        return fetch('/set_chat_state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        }).then(resp => {
          if (!resp.ok) throw new Error('No se pudo actualizar el estado');
          return resp.json();
        });
      }

      function formatChatDate(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) return '';
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
      }

      function renderChatList(data) {
        const getTimestamp = ts => ts ? new Date(ts).getTime() : 0;
        const sorted = Array.isArray(data) ? [...data] : [];
        sorted.sort((a, b) => getTimestamp(b.last_timestamp) - getTimestamp(a.last_timestamp));
        chatListEl.innerHTML='';
        sorted.forEach(c => {
          const serverTime = c.last_timestamp ? new Date(c.last_timestamp).getTime() : null;
          const prevTime = lastChatTimestamps[c.numero];
          if (serverTime && prevTime && serverTime > prevTime && c.numero !== currentChat) {
            const mediaPlaying = Array.from(document.querySelectorAll('audio, video')).some(m => !m.paused);
            if (!mediaPlaying) playAlertSound();
          }
          if (serverTime) lastChatTimestamps[c.numero] = serverTime;
          const li = document.createElement('li');
          const labelWrapper = document.createElement('span');
          labelWrapper.className = 'chat-list-label';

          const sourceInfo = resolveChatSourceLogo(c.first_link_url);
          const sourceIcon = document.createElement('img');
          sourceIcon.className = 'chat-source-icon';
          sourceIcon.src = CHAT_SOURCE_LOGOS[sourceInfo.key] || CHAT_SOURCE_LOGOS.whatsapp;
          sourceIcon.alt = sourceInfo.label;
          sourceIcon.title = sourceInfo.label;

          const isInstagramChat = c.first_link_url === 'instagram';
          const isMessengerChat = c.first_link_url === 'messenger';
          const avatarUrl = isInstagramChat
            ? (c.instagram_profile_pic || '')
            : (isMessengerChat ? (c.messenger_profile_pic || '') : '');
          if (avatarUrl) {
            const avatar = document.createElement('img');
            avatar.className = 'chat-profile-avatar';
            avatar.src = avatarUrl;
            const avatarName = isInstagramChat
              ? c.instagram_username
              : (isMessengerChat ? c.messenger_name : null);
            avatar.alt = avatarName ? `Foto de ${avatarName}` : 'Foto de perfil';
            avatar.loading = 'lazy';
            avatar.onerror = () => avatar.remove();
            labelWrapper.appendChild(avatar);
          }

          labelWrapper.appendChild(sourceIcon);

          const textContainer = document.createElement('span');
          textContainer.className = 'chat-list-texts';

          const textLabel = document.createElement('span');
          textLabel.className = 'chat-list-text';
          const primaryName = isInstagramChat
            ? (c.instagram_username || c.alias || c.numero)
            : (isMessengerChat ? (c.messenger_name || c.alias || c.numero) : (c.alias || c.numero));
          textLabel.textContent = primaryName;

          const secondaryText = (() => {
            if (isInstagramChat && c.alias && c.instagram_username && c.alias !== c.instagram_username) {
              return c.alias;
            }
            if (isMessengerChat && c.alias && c.messenger_name && c.alias !== c.messenger_name) {
              return c.alias;
            }
            if (c.alias && c.messenger_name && c.alias !== c.messenger_name) {
              return c.alias;
            }
            if (primaryName !== c.numero) {
              return c.numero || '';
            }
            return '';
          })();

          textContainer.appendChild(textLabel);
          if (secondaryText) {
            const secondaryLabel = document.createElement('span');
            secondaryLabel.className = 'chat-list-secondary';
            secondaryLabel.textContent = secondaryText;
            textContainer.appendChild(secondaryLabel);
          }

          labelWrapper.appendChild(textContainer);
          li.appendChild(labelWrapper);
          if (c.estado === 'error_flujo') {
            const alertIcon = document.createElement('span');
            alertIcon.className = 'chat-alert';
            alertIcon.textContent = '‚ö†Ô∏è';
            alertIcon.title = 'Atenci√≥n requerida';
            li.insertBefore(alertIcon, li.firstChild);
          }
          if (c.estado) {
            li.classList.add('estado-' + c.estado);
            const estadoDef = chatStateDefinitionMap.get(c.estado);
            const estadoLabel = c.estado_label || (estadoDef && estadoDef.label) || c.estado;
            if (estadoLabel) {
              li.title = `Estado: ${estadoLabel}`;
            } else if (c.estado) {
              li.title = `Estado: ${c.estado}`;
            }
          } else {
            li.removeAttribute('title');
          }
          if (currentChat && c.numero === currentChat) {
            li.classList.add('active');
            updateMobileChatHeader(c);
          }

          // Badges por roles
          li.querySelectorAll('.badge').forEach(b => b.remove());
          li.querySelectorAll('.badges').forEach(bc => bc.remove());
          li.querySelectorAll('.chat-list-meta').forEach(bc => bc.remove());
          const metaContainer = document.createElement('span');
          metaContainer.className = 'chat-list-meta';
          if (c.assigned_user_name) {
            const assignee = document.createElement('span');
            assignee.className = 'chat-assignee';
            assignee.textContent = c.assigned_user_name;
            metaContainer.appendChild(assignee);
          }
          const lastDate = formatChatDate(c.last_timestamp);
          if (lastDate) {
            const lastMessageDate = document.createElement('span');
            lastMessageDate.className = 'chat-assignee chat-last-date';
            lastMessageDate.textContent = lastDate;
            metaContainer.appendChild(lastMessageDate);
          }
          const badgeContainer = document.createElement('span');
          badgeContainer.className = 'badges';
          if (c.estado) {
            const estadoDef = chatStateDefinitionMap.get(c.estado);
            const estadoLabel = c.estado_label || (estadoDef && estadoDef.label) || c.estado;
            if (estadoLabel) {
              const stateBadge = document.createElement('span');
              stateBadge.className = 'badge state-badge';
              stateBadge.textContent = estadoLabel;
              const estadoColor = c.estado_color || (estadoDef && estadoDef.color);
              const estadoTextColor = c.estado_text_color || (estadoDef && estadoDef.text_color);
              if (estadoColor) {
                stateBadge.style.backgroundColor = estadoColor;
              }
              if (estadoTextColor) {
                stateBadge.style.color = estadoTextColor;
              }
              badgeContainer.appendChild(stateBadge);
            }
          }
          if (c.roles_kw && c.roles_kw.length) {
            c.roles_kw.forEach(r => {
              const badge = document.createElement('span');
              badge.className = 'badge';
              badge.textContent = getRoleBadge(r);
              badgeContainer.appendChild(badge);
            });
          }
          if (badgeContainer.children.length > 0) {
            metaContainer.appendChild(badgeContainer);
          }
          if (metaContainer.children.length > 0) {
            li.appendChild(metaContainer);
          }

          // Al hacer clic, seleccionar el chat
          li.onclick = () => {
            hideChatContextMenu();
            selectChat(c.numero, li);
          };

          // Contextual: alias y estado
          li.addEventListener('contextmenu', e => {
            e.preventDefault();
            openChatContextMenu(e, c);
          });
          addLongPressListener(li, event => {
            const touch = event.touches[0];
            if (!touch) return;
            openChatContextMenu({ clientX: touch.clientX, clientY: touch.clientY }, c);
          });

          chatListEl.appendChild(li);
        });
      }

      function fetchChatList(allowRetry = true) {
        if (!chatContextMenu.classList.contains('show')) {
          hideChatContextMenu();
        }
        const requestSeq = ++chatListRequestSeq;
        const params = new URLSearchParams();
        if (buscadorInput && buscadorInput.value.trim()) {
          params.set('q', buscadorInput.value.trim());
        }
        const queryString = params.toString();
        const requestUrl = queryString ? `/get_chat_list?${queryString}` : '/get_chat_list';
        fetch(requestUrl, { cache: 'no-store' })
          .then(resp => {
            if (!resp.ok) throw new Error(`No se pudo cargar la lista de chats (HTTP ${resp.status})`);
            return resp.json();
          })
          .then(data => {
            if (!Array.isArray(data)) throw new Error('Respuesta de chats inv√°lida');
            if (requestSeq !== chatListRequestSeq) return;
            todosChats = data;
            applyChatFilters();
          })
          .catch(err => {
            console.error('Error al cargar la lista de chats', err);
            if (allowRetry) {
              fetch(requestUrl)
                .then(resp => {
                  if (!resp.ok) throw new Error(`No se pudo cargar la lista de chats (HTTP ${resp.status})`);
                  return resp.json();
                })
                .then(data => {
                  if (!Array.isArray(data)) throw new Error('Respuesta de chats inv√°lida');
                  if (requestSeq !== chatListRequestSeq) return;
                  todosChats = data;
                  applyChatFilters();
                })
                .catch(innerErr => {
                  console.error('Reintento sin bypass de cach√© fall√≥', innerErr);
                  if (chatListEl.children.length === 0 && Array.isArray(todosChats) && todosChats.length) {
                    applyChatFilters();
                  }
                });
              return;
            }
            if (chatListEl.children.length === 0 && Array.isArray(todosChats) && todosChats.length) {
              applyChatFilters();
            }
          });
      }

      function startChatListPolling() {
        if (chatListPoll) return;
        if (!pollingFallbackActive) return;
        chatListPoll = setInterval(fetchChatList, 5000);
      }

      function stopChatListPolling() {
        if (!chatListPoll) return;
        clearInterval(chatListPoll);
        chatListPoll = null;
      }

      function schedulePollingFallback() {
        if (socketFallbackTimer || socketConnected) return;
        socketFallbackTimer = setTimeout(() => {
          socketFallbackTimer = null;
          if (!socketConnected) {
            pollingFallbackActive = true;
            startChatListPolling();
            if (currentChat) {
              startMessagePolling();
            }
          }
        }, 3000);
      }

      function startMessagePolling() {
        if (autoRefresh) return;
        if (!pollingFallbackActive) return;
        autoRefresh = setInterval(loadMessages, 3000);
      }

      function stopMessagePolling() {
        if (!autoRefresh) return;
        clearInterval(autoRefresh);
        autoRefresh = null;
      }

      function setupSocket() {
        if (typeof io === 'undefined') return;
        socket = io();

        socket.on('connect', () => {
          socketConnected = true;
          pollingFallbackActive = false;
          if (socketFallbackTimer) {
            clearTimeout(socketFallbackTimer);
            socketFallbackTimer = null;
          }
          stopChatListPolling();
          stopMessagePolling();
          fetchChatList();
          if (currentChat) {
            socket.emit('join_chat', { numero: currentChat });
            loadMessages();
          }
        });

        socket.on('disconnect', () => {
          socketConnected = false;
          schedulePollingFallback();
        });

        socket.on('chat_list_update', () => {
          fetchChatList();
        });

        socket.on('chat_update', data => {
          if (!data || !data.numero) return;
          if (currentChat && data.numero === currentChat) {
            loadMessages();
          }
        });

        socket.on('typing_update', data => {
          if (!data || !data.numero) return;
          if (currentChat && data.numero === currentChat) {
            const atBottom = chatBoxEl.scrollTop + chatBoxEl.clientHeight >= chatBoxEl.scrollHeight - 5;
            updateTypingIndicator(Boolean(data.is_typing), atBottom);
          }
        });
      }

      // Seleccionar chat
      function selectChat(numero, liEl) {
        const previousChat = currentChat;
        currentChat = numero;
        const chatData = todosChats.find(c => c.numero === numero) || {};
        lastCount = 0; // reset count so the initial load doesn't trigger alerts
        lastIncomingWaId = null;
        lastTypingSent = 0;
        shouldScrollToBottomOnLoad = true;
        updateTypingIndicator(false);
        // marcar activo
        document.querySelectorAll('#chatList li').forEach(li => li.classList.remove('active'));
        liEl.classList.add('active');
        if (socketConnected && socket) {
          if (previousChat && previousChat !== numero) {
            socket.emit('leave_chat', { numero: previousChat });
          }
          socket.emit('join_chat', { numero });
        }
        updateMobileSidebarState(false);
        stopMessagePolling();
        if (!socketConnected) {
          schedulePollingFallback();
        }
        updateMobileChatHeader(chatData);
        loadMessages(); loadBotonera();
      }

      function updateMobileChatHeader(chatData) {
        if (!mobileChatTitle || !mobileChatSubtitle || !mobileChatActions) return;
        if (!chatData) {
          mobileChatTitle.textContent = 'Selecciona un chat';
          mobileChatSubtitle.textContent = '';
          if (mobileChatAvatar) {
            mobileChatAvatar.hidden = true;
            mobileChatAvatar.removeAttribute('src');
          }
          mobileChatActions.disabled = true;
          if (chatFinishButton) {
            chatFinishButton.disabled = true;
          }
          return;
        }
        const isInstagramChat = chatData.first_link_url === 'instagram';
        const isMessengerChat = chatData.first_link_url === 'messenger';
        const title = isInstagramChat
          ? (chatData.instagram_username || chatData.alias || chatData.numero || '')
          : (isMessengerChat ? (chatData.messenger_name || chatData.alias || chatData.numero || '') : (chatData.alias || chatData.numero || ''));
        const estadoDef = chatStateDefinitionMap.get(chatData.estado);
        mobileChatTitle.textContent = title || 'Chat';
        const estadoLabel = chatData.estado_label || (estadoDef && estadoDef.label) || chatData.estado;
        mobileChatSubtitle.textContent = estadoLabel ? `Estado: ${estadoLabel}` : '';
        if (mobileChatAvatar) {
          const avatarUrl = isInstagramChat
            ? (chatData.instagram_profile_pic || '')
            : (isMessengerChat ? (chatData.messenger_profile_pic || '') : '');
          if (avatarUrl) {
            mobileChatAvatar.hidden = false;
            mobileChatAvatar.src = avatarUrl;
            const avatarName = isInstagramChat
              ? chatData.instagram_username
              : (isMessengerChat ? chatData.messenger_name : null);
            mobileChatAvatar.alt = avatarName
              ? `Foto de ${avatarName}`
              : 'Foto de perfil';
          } else {
            mobileChatAvatar.hidden = true;
            mobileChatAvatar.removeAttribute('src');
          }
        }
        mobileChatActions.disabled = false;
        if (chatFinishButton) {
          chatFinishButton.disabled = false;
        }
      }

      function updateTypingIndicator(isActive, shouldMaintainScroll = false) {
        if (isActive) {
          if (!typingIndicatorEl.parentElement) {
            chatBoxEl.appendChild(typingIndicatorEl);
          }
          typingIndicatorEl.classList.add('visible');
          if (shouldMaintainScroll) {
            chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
          }
        } else {
          typingIndicatorEl.classList.remove('visible');
          if (typingIndicatorEl.parentElement) {
            typingIndicatorEl.parentElement.removeChild(typingIndicatorEl);
          }
        }
      }

      function scrollChatToBottom() {
        chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
      }

      function ensureScrollAfterMediaLoad(shouldScroll) {
        if (!shouldScroll) return;
        const mediaEls = chatBoxEl.querySelectorAll('img, video');
        mediaEls.forEach(media => {
          if (media.tagName === 'IMG') {
            if (media.complete) return;
            media.addEventListener('load', scrollChatToBottom, { once: true });
            media.addEventListener('error', scrollChatToBottom, { once: true });
            return;
          }
          if (media.readyState >= 1) return;
          media.addEventListener('loadedmetadata', scrollChatToBottom, { once: true });
          media.addEventListener('error', scrollChatToBottom, { once: true });
        });
      }

      // Cargar mensajes
      function loadMessages() {
        if (!currentChat) return;
        // no interrumpir si hay media reproduci√©ndose
        const mediaEls = chatBoxEl.querySelectorAll('audio, video');
        for (let m of mediaEls) if (!m.paused) return;

        const requestId = ++messagesRequestSeq;
        fetch(`/get_chat/${currentChat}`, { cache: 'no-store' })
          .then(r=>r.json())
          .then(data => {
            if (requestId < lastRenderedMessagesSeq) return;
            lastRenderedMessagesSeq = requestId;
            const msgs = data.mensajes, total = msgs.length;
            const atBottom = shouldScrollToBottomOnLoad
              || chatBoxEl.scrollTop + chatBoxEl.clientHeight >= chatBoxEl.scrollHeight - 5;
            const currentFingerprint = buildMessagesFingerprint(msgs);
            if (currentFingerprint === lastMessagesFingerprint) {
              updateTypingIndicator(Boolean(data.is_typing), atBottom);
              if (atBottom) chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
              shouldScrollToBottomOnLoad = false;
              return;
            }
            lastMessagesFingerprint = currentFingerprint;
            const previousCount = lastCount;
            const previousIncoming = lastIncomingWaId;
            const nextChildren = document.createDocumentFragment();
            lastCount = 0;
            let newestIncoming = lastIncomingWaId;
            for (let i=0; i<total; i++){
              const [txt, tipo, url, opciones, ts, linkUrl, linkTitle, linkBody, linkThumb,
                     waId, replyWaId, replyId, replyText, replyTipo, replyUrl,
                     flowName, flowJson, flowSegments] = msgs[i];
              const mediaUrl = normalizeMediaUrl(url);
              const safeReplyUrl = normalizeMediaUrl(replyUrl);
              const safeLinkThumb = normalizeMediaUrl(linkThumb);
              const safeLinkUrl = normalizeMediaUrl(linkUrl);
              const div = document.createElement('div');
              // map tipo a bubble class
              let bubble = 'cliente';
              if (tipo.startsWith('bot'))    bubble='bot';
              if (tipo.startsWith('asesor')) bubble='asesor';
              div.className = `bubble ${bubble} message`;

              if (replyWaId) {
                const replyDiv = document.createElement('div');
                replyDiv.className = 'reply';
                const replyIsAudio = (replyTipo && replyTipo.includes('audio')) || guessAudioType(safeReplyUrl);
                if (replyTipo && replyTipo.endsWith('_image') && safeReplyUrl) {
                  const img = document.createElement('img');
                  img.src = safeReplyUrl;
                  img.alt = replyText || 'Imagen del mensaje citado';
                  img.classList.add('chat-image');
                  replyDiv.appendChild(img);
                } else if (replyIsAudio && safeReplyUrl) {
                  const a = createAudioElement(safeReplyUrl);
                  replyDiv.appendChild(a);
                } else if (replyTipo && replyTipo.includes('video') && safeReplyUrl) {
                  const v = document.createElement('video');
                  v.controls = true; v.src = safeReplyUrl; v.style.maxWidth = '100px';
                  replyDiv.appendChild(v);
                }
                if (replyText) {
                  const p = document.createElement('p');
                  p.textContent = replyText;
                  replyDiv.appendChild(p);
                }
                div.appendChild(replyDiv);
              }

              // insertar media o texto
              if (tipo === 'referral' && safeLinkUrl) {
                const a = document.createElement('a');
                a.href = safeLinkUrl; a.target = '_blank'; a.style.textDecoration = 'none';
                const card = document.createElement('div');
                card.style.display = 'flex';
                const img = document.createElement('img');
                img.src = safeLinkThumb; img.style.width = '100px'; img.style.marginRight = '8px';
                const textBox = document.createElement('div');
                textBox.innerHTML = `<strong>${linkTitle}</strong><br>${linkBody}`;
                card.appendChild(img); card.appendChild(textBox); a.appendChild(card);
                div.appendChild(a);
              } else if (tipo.endsWith('_image') && mediaUrl) {
                const img = document.createElement('img');
                img.src = mediaUrl;
                img.alt = txt || 'Imagen del mensaje';
                img.classList.add('chat-image');
                div.appendChild(img);
              } else if ((tipo.includes('audio') || guessAudioType(mediaUrl)) && mediaUrl) {
                const a = createAudioElement(mediaUrl);
                div.appendChild(a);
              } else if (tipo.includes('video') && mediaUrl) {
                const v = document.createElement('video');
                v.controls=true; v.src=mediaUrl; v.style.maxWidth='200px';
                div.appendChild(v);
              }

              // texto (caption o mensajes)
              if (txt) {
                const p = document.createElement('p');
                p.textContent = txt;
                div.appendChild(p);
              }

              const optionsSource = opciones || (typeof url === 'string' && url.trim().startsWith('[') ? url : null);
              const parsedOptions = parseMessageOptions(optionsSource);
              if (parsedOptions.length) {
                const optionsWrap = document.createElement('div');
                optionsWrap.className = 'message-options';
                const titleEl = document.createElement('div');
                titleEl.className = 'message-options__title';
                titleEl.textContent = 'Opciones enviadas:';
                optionsWrap.appendChild(titleEl);
                const listEl = document.createElement('div');
                listEl.className = 'message-options__list';
                parsedOptions.forEach(option => {
                  const chip = document.createElement('span');
                  chip.className = 'message-options__item';
                  chip.textContent = option.label;
                  if (option.detail) chip.title = option.detail;
                  listEl.appendChild(chip);
                });
                optionsWrap.appendChild(listEl);
                div.appendChild(optionsWrap);
              }

              const flowCard = createFlowCard(flowName, flowJson);
              if (flowCard) {
                div.appendChild(flowCard);
              }

              const segmentsCard = createFlowSegmentsCard(flowSegments, txt);
              if (segmentsCard) {
                div.appendChild(segmentsCard);
              }

              // fecha y hora
              if (ts) {
                const timeSpan = document.createElement('div');
                timeSpan.className = 'timestamp';
                const formattedTs = formatBogotaTimestamp(ts);
                timeSpan.textContent = formattedTs || ts;
                div.appendChild(timeSpan);
              }

              if (waId) {
                div.dataset.waId = waId;
                if (txt) div.dataset.text = txt;
                if (mediaUrl) div.dataset.url = mediaUrl;
                div.dataset.tipo = tipo;
                if (tipo && tipo.startsWith('cliente')) {
                  newestIncoming = waId;
                }
                div.addEventListener('contextmenu', e => {
                  e.preventDefault();
                  e.stopPropagation();
                  openReplyMenuAt(e.pageX, e.pageY, div);
                });
                addLongPressListener(div, event => {
                  const touch = event.touches[0];
                  if (!touch) return;
                  openReplyMenuAt(touch.pageX, touch.pageY, div);
                });
              }

              nextChildren.appendChild(div);

              if (lastCount > 0 && bubble !== 'asesor' && previousCount > 0 && (waId !== previousIncoming)) {
                const mediaPlaying = Array.from(chatBoxEl.querySelectorAll('audio, video')).some(m => !m.paused);
                if (!mediaPlaying) playAlertSound();
              }
              lastCount = i + 1;
            }
            reconcilePendingVideoUploads(msgs);
            appendPendingVideoUploads(nextChildren);
            chatBoxEl.replaceChildren(nextChildren);
            lastIncomingWaId = newestIncoming;
            updateTypingIndicator(Boolean(data.is_typing), atBottom);
            const shouldForceScroll = shouldScrollToBottomOnLoad;
            if (atBottom) scrollChatToBottom();
            ensureScrollAfterMediaLoad(shouldForceScroll);
            shouldScrollToBottomOnLoad = false;
          });
      }

      function buildMessagesFingerprint(msgs) {
        if (!Array.isArray(msgs) || msgs.length === 0) return '0';
        const first = msgs[0] || [];
        const last = msgs[msgs.length - 1] || [];
        return `${msgs.length}|${first[9] || ''}|${last[9] || ''}|${last[4] || ''}`;
      }

      // Botones r√°pidos
      function loadBotonera() {
        fetch('/get_botones')
          .then(r=>r.json())
          .then(btns => {
            botoneraEl.innerHTML='';

            const crearBoton = (boton, label) => {
              const btn = document.createElement('button');
              btn.textContent = boton.nombre || label;
              btn.onclick = () => {
                if (!currentChat || isBotoneraSending) return;
                isBotoneraSending = true;
                btn.disabled = true;
                const tipoRespuesta = boton.tipo || 'texto';
                const envios = [];
                const replyTarget = replyTo;
                replyTo = null;
                replyPreviewEl.style.display='none';
                replyPreviewEl.innerHTML='';

                if (['image','video','audio','document'].includes(tipoRespuesta)) {
                  const urls = (boton.media_urls && boton.media_urls.length) ? boton.media_urls : [null];
                  urls.forEach((url, index) => {
                    envios.push(fetch('/send_message', {
                      method:'POST',
                      headers:{'Content-Type':'application/json'},
                      body:JSON.stringify({
                        numero: currentChat,
                        mensaje: index === 0 ? (boton.mensaje || '') : '',
                        tipo_respuesta: tipoRespuesta,
                        opciones: url,
                        reply_to_wa_id: replyTarget
                      })
                    }));
                  });
                } else {
                  envios.push(fetch('/send_message', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                      numero: currentChat,
                      mensaje: boton.mensaje || '',
                      tipo_respuesta: tipoRespuesta,
                      opciones: boton.opciones,
                      reply_to_wa_id: replyTarget
                    })
                  }));
                }

                Promise.all(envios)
                  .then(async responses => {
                    for (const res of responses) {
                      if (!res.ok) {
                        const msg = await extractSendError(res);
                        throw new Error(msg);
                      }
                    }
                    loadMessages();
                    fetchChatList();
                    isBotoneraSending = false;
                    btn.disabled = false;
                  })
                  .catch(err => {
                    const msg = (err && err.message) ? err.message : 'No se pudo enviar el mensaje';
                    alert(msg);
                    isBotoneraSending = false;
                    btn.disabled = false;
                  });
              };
              return btn;
            };

            const grupos = btns.reduce((acc, boton) => {
              const clave = boton.categoria || 'General';
              if (!acc[clave]) acc[clave] = [];
              acc[clave].push(boton);
              return acc;
            }, {});

            let contador = 1;
            Object.entries(grupos).forEach(([categoria, botonesLista]) => {
              const details = document.createElement('details');
              details.className = 'botonera-group';
              details.open = true;
              const summary = document.createElement('summary');
              summary.textContent = categoria;
              details.appendChild(summary);

              const contenedor = document.createElement('div');
              contenedor.className = 'botonera-buttons';

              botonesLista.forEach(boton => {
                const btn = crearBoton(boton, contador);
                contador += 1;
                contenedor.appendChild(btn);
              });

              details.appendChild(contenedor);
              botoneraEl.appendChild(details);
            });
          });
      }

      // Enviar texto
      sendBtn.onclick = () => {
        if (imageDraft) {
          sendImageDraft();
          return;
        }
        if (videoDraft) {
          sendVideoDraft();
          return;
        }
        if (isSending || isSendingImage) return;
        const txt = messageInput.value.trim();
        if (!txt||!currentChat) return;
        const now = Date.now();
        if (txt === lastSentMessage && now - lastSentTimestamp < 1500) return;
        lastSentMessage = txt;
        lastSentTimestamp = now;
        const replyTarget = replyTo;
        messageInput.value='';
        messageInput.focus();
        replyTo=null;
        replyPreviewEl.style.display='none';
        replyPreviewEl.innerHTML='';
        triggerTypingSignal(true);
        startSending();
        fetch('/send_message',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({numero:currentChat,mensaje:txt,reply_to_wa_id:replyTarget})
        }).then(async res=>{
          if(!res.ok){
            const msg = await extractSendError(res);
            alert(msg);
            lastSentMessage = '';
            lastSentTimestamp = 0;
            stopSending();
            return;
          }
          loadMessages(); fetchChatList();
          stopSending();
        }).catch(err=>{
          console.error('Error enviando mensaje', err);
          const msg = (err && err.message) ? err.message : 'No se pudo enviar el mensaje';
          alert(msg);
          lastSentMessage = '';
          lastSentTimestamp = 0;
          stopSending();
        });
      };

      function triggerTypingSignal(force = false) {
        if (!currentChat) return;
        const now = Date.now();
        if (!force && now - lastTypingSent < TYPING_SIGNAL_THROTTLE) return;
        lastTypingSent = now;
        const payload = {
          numero: currentChat,
          message_id: lastIncomingWaId,
          include_read: true
        };
        if (socketConnected && socket) {
          socket.emit('typing_signal', payload);
          return;
        }
        fetch('/typing_signal', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        }).catch(err => console.error('Error enviando indicador de escritura', err));
      }

      messageInput.addEventListener('input', () => {
        if (typingSignalTimeout) clearTimeout(typingSignalTimeout);
        typingSignalTimeout = setTimeout(() => {
          typingSignalTimeout = null;
          triggerTypingSignal();
        }, 300);
        const currentValue = messageInput.value || '';
        if (!currentValue.trim()) return;
        const endsWithBoundary = /[\\s.,;:!?)]$/.test(currentValue);
        scheduleAutocorrect(endsWithBoundary ? 150 : 1000);
      });

      messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (imageDraft) {
            sendImageDraft();
            return;
          }
          if (!isSending && !isSendingImage && !isSendingAudio && !isRecordingAudio) sendBtn.click();
        }
      });

      // Attach menu
      const attachBtn = document.getElementById('attachBtn');
      const attachMenu = document.getElementById('attachMenu');
      attachBtn.onclick = e => {
        e.stopPropagation();
        attachMenu.classList.toggle('show');
      };
      document.addEventListener('click', () => attachMenu.classList.remove('show'));

      // File inputs y grabaci√≥n de audio
      const imgIn = document.getElementById('imageInput');
      const audIn = document.getElementById('audioInput');
      const vidIn = document.getElementById('videoInput');
      const recordControls = document.getElementById('recordControls');
      const recordTimerEl = document.getElementById('recordTimer');
      const startRecBtn = document.getElementById('startRecord');
      const stopRecBtn  = document.getElementById('stopRecord');
      let mediaRecorder = null;
      let audioChunks = [];
      let recordTimerInterval = null;
      let recordStartTime = null;
      document.getElementById('attachImage').onclick = () => imgIn.click();
      let recordedMimeType = '';
      document.getElementById('attachAudio').onclick = async () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          setAudioStatus('Selecciona un archivo de audio para enviarlo.', 'info', 3000);
          audIn.click();
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const supportedTypes = [
            'audio/ogg;codecs=opus',
            'audio/webm;codecs=opus',
            'audio/webm'
          ];
          recordedMimeType = supportedTypes.find(t => {
            return typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported(t);
          }) || '';
          const recorderOpts = recordedMimeType ? { mimeType: recordedMimeType } : undefined;

          mediaRecorder = new MediaRecorder(stream, recorderOpts);
          audioChunks = [];
          mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
          mediaRecorder.onstop = async () => {
            isRecordingAudio = false;
            updateSendButtons();
            stopRecordTimer();
            const totalSize = audioChunks.reduce((acc, chunk) => acc + (chunk ? chunk.size : 0), 0);
            if (!totalSize) {
              setAudioStatus('No se captur√≥ audio. Intenta de nuevo.', 'error', 4000);
              mediaRecorder.stream.getTracks().forEach(t=>t.stop());
              return;
            }
            const blobType = recordedMimeType || 'audio/webm';
            const extension = blobType.includes('ogg') ? 'ogg' : 'webm';
            const blob = new Blob(audioChunks, { type: blobType });
            const file = new File([blob], `recording.${extension}`, { type: blobType });
            await sendAudioFile(file);
            mediaRecorder.stream.getTracks().forEach(t=>t.stop());
          };
          recordControls.style.display = 'block';
          attachMenu.classList.remove('show');
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
          resetRecordTimer();
          setAudioStatus('Micr√≥fono listo. Presiona grabar para empezar.', 'info', 2500);
        } catch(err) {
          setAudioStatus('No se pudo acceder al micr√≥fono. Sube un archivo.', 'error', 4000);
          audIn.click();
        }
      };
      document.getElementById('attachVideo').onclick = () => vidIn.click();

      startRecBtn.onclick = () => {
        if (mediaRecorder) {
          mediaRecorder.start();
          startRecBtn.disabled = true;
          stopRecBtn.disabled = false;
          isRecordingAudio = true;
          startRecordTimer();
          setAudioStatus('Grabando‚Ä¶', 'recording');
          updateSendButtons();
        }
      };
      stopRecBtn.onclick = () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          recordControls.style.display = 'none';
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
          isRecordingAudio = false;
          stopRecordTimer();
          setAudioStatus('Procesando grabaci√≥n‚Ä¶', 'uploading');
          updateSendButtons();
        }
      };

      function formatRecordTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }

      function updateRecordTimer() {
        if (!recordTimerEl || recordStartTime === null) return;
        const elapsedSeconds = Math.floor((Date.now() - recordStartTime) / 1000);
        recordTimerEl.textContent = formatRecordTime(elapsedSeconds);
        recordTimerEl.dataset.state = 'recording';
      }

      function startRecordTimer() {
        recordStartTime = Date.now();
        updateRecordTimer();
        if (recordTimerInterval) clearInterval(recordTimerInterval);
        recordTimerInterval = setInterval(updateRecordTimer, 500);
      }

      function stopRecordTimer() {
        if (recordTimerInterval) {
          clearInterval(recordTimerInterval);
          recordTimerInterval = null;
        }
        recordStartTime = null;
        if (recordTimerEl) {
          recordTimerEl.dataset.state = 'idle';
        }
      }

      function resetRecordTimer() {
        stopRecordTimer();
        if (recordTimerEl) {
          recordTimerEl.textContent = '00:00';
        }
      }

      async function sendFile(inputEl, endpoint) {
        if (!currentChat) return;
        const file = inputEl.files[0];
        if (!file) return;
        if (endpoint === 'send_audio') {
          await sendAudioFile(file);
          inputEl.value='';
          return;
        }
        if (endpoint === 'send_video') {
          prepareVideoDraft(file);
          inputEl.value='';
          return;
        }
        await sendMediaUpload(file, endpoint);
        inputEl.value='';
      }

      async function sendAudioFile(file) {
        if (!currentChat || !file) return;
        isSendingAudio = true;
        updateSendButtons();
        setAudioStatus('Subiendo audio‚Ä¶', 'uploading');
        const form = new FormData();
        form.append('audio', file);
        form.append('caption', messageInput ? messageInput.value.trim() : '');
        form.append('numero', currentChat);
        try {
          const res = await fetch('/send_audio', { method:'POST', body: form });
          if (!res.ok) {
            const msg = await extractSendError(res);
            throw new Error(msg);
          }
          let confirmation = 'Audio en cola para enviar';
          try {
            const data = await res.json();
            if (data && data.url) {
              confirmation = 'Audio en cola y listo para reproducir';
            }
          } catch (parseErr) {
            // ignore parse errors and keep fallback confirmation
          }
          setAudioStatus(confirmation, 'success', 3500);
          attachMenu.classList.remove('show');
          loadMessages(); fetchChatList();
        } catch (err) {
          const msg = (err && err.message) ? err.message : 'No se pudo enviar el audio';
          setAudioStatus(msg, 'error', 5000);
          alert(msg);
        } finally {
          isSendingAudio = false;
          updateSendButtons();
          if (audIn) audIn.value = '';
          if (messageInput) messageInput.focus();
        }
      }

      function clearImageDraft() {
        if (imageDraft && imageDraft.previewUrl) {
          URL.revokeObjectURL(imageDraft.previewUrl);
        }
        imageDraft = null;
        if (imagePreviewThumb) imagePreviewThumb.removeAttribute('src');
        if (imagePreviewChip) imagePreviewChip.hidden = true;
        if (messageInput) {
          messageInput.placeholder = 'Escribe un mensaje‚Ä¶';
        }
        updateSendButtons();
      }

      function clearVideoDraft() {
        if (videoDraft && videoDraft.previewUrl) {
          URL.revokeObjectURL(videoDraft.previewUrl);
        }
        videoDraft = null;
        if (videoPreviewThumb) {
          videoPreviewThumb.removeAttribute('src');
          videoPreviewThumb.load();
        }
        if (videoPreviewChip) videoPreviewChip.hidden = true;
        if (messageInput) {
          messageInput.placeholder = 'Escribe un mensaje‚Ä¶';
        }
        updateSendButtons();
      }

      function extractFileByType(dataTransfer, typePrefix) {
        if (!dataTransfer) return null;
        if (dataTransfer.files && dataTransfer.files.length) {
          const file = Array.from(dataTransfer.files).find(f => f.type && f.type.startsWith(typePrefix));
          if (file) return file;
        }
        if (dataTransfer.items && dataTransfer.items.length) {
          const item = Array.from(dataTransfer.items).find(i => i.kind === 'file' && i.type && i.type.startsWith(typePrefix));
          if (item) return item.getAsFile();
        }
        return null;
      }

      function extractImageFile(dataTransfer) {
        return extractFileByType(dataTransfer, 'image/');
      }

      function extractVideoFile(dataTransfer) {
        return extractFileByType(dataTransfer, 'video/');
      }

      function resolveDraggedMedia(dataTransfer, { acceptImages = true, acceptVideos = false } = {}) {
        if (!dataTransfer) return null;
        if (acceptImages) {
          const imageFile = extractImageFile(dataTransfer);
          if (imageFile) return { type: 'image', file: imageFile };
        }
        if (acceptVideos) {
          const videoFile = extractVideoFile(dataTransfer);
          if (videoFile) return { type: 'video', file: videoFile };
        }
        return null;
      }

      function prepareImageDraft(file) {
        if (!file || !file.type || !file.type.startsWith('image/')) return;
        if (videoDraft) {
          clearVideoDraft();
        }
        if (imageDraft && imageDraft.previewUrl) {
          URL.revokeObjectURL(imageDraft.previewUrl);
        }
        imageDraft = {
          file,
          previewUrl: URL.createObjectURL(file)
        };
        if (imagePreviewThumb) {
          imagePreviewThumb.src = imageDraft.previewUrl;
        }
        if (imagePreviewChip) {
          imagePreviewChip.hidden = false;
        }
        if (messageInput) {
          messageInput.placeholder = 'Agrega un mensaje para enviar la imagen‚Ä¶';
          messageInput.focus();
        }
        attachMenu.classList.remove('show');
        updateSendButtons();
      }

      function prepareVideoDraft(file) {
        if (!file || !file.type || !file.type.startsWith('video/')) return;
        if (imageDraft) {
          clearImageDraft();
        }
        if (videoDraft && videoDraft.previewUrl) {
          URL.revokeObjectURL(videoDraft.previewUrl);
        }
        videoDraft = {
          file,
          previewUrl: URL.createObjectURL(file)
        };
        if (videoPreviewThumb) {
          videoPreviewThumb.src = videoDraft.previewUrl;
          videoPreviewThumb.load();
        }
        if (videoPreviewChip) {
          videoPreviewChip.hidden = false;
        }
        if (messageInput) {
          messageInput.placeholder = 'Agrega un mensaje para enviar el video‚Ä¶';
          messageInput.focus();
        }
        attachMenu.classList.remove('show');
        updateSendButtons();
      }

      async function sendImageDraft() {
        if (!imageDraft || !currentChat || isSendingImage) return;
        attachMenu.classList.remove('show');
        isSendingImage = true;
        updateSendButtons();
        const form = new FormData();
        form.append('image', imageDraft.file);
        form.append('caption', messageInput ? messageInput.value.trim() : '');
        form.append('numero', currentChat);
        try {
          const res = await fetch('/send_image', { method:'POST', body: form });
          if (!res.ok) {
            const msg = await extractSendError(res);
            throw new Error(msg);
          }
          clearImageDraft();
          if (messageInput) {
            messageInput.value = '';
          }
          loadMessages();
          fetchChatList();
        } catch (err) {
          const msg = (err && err.message) ? err.message : 'No se pudo enviar la imagen';
          alert(msg);
        } finally {
          isSendingImage = false;
          updateSendButtons();
          if (messageInput) messageInput.focus();
        }
      }

      async function sendVideoDraft() {
        if (!videoDraft || !currentChat || isSendingVideo) return;
        attachMenu.classList.remove('show');
        isSendingVideo = true;
        updateSendButtons();
        setVideoStatus('Procesando video‚Ä¶', 'uploading');
        const caption = messageInput ? messageInput.value.trim() : '';
        const pendingId = addPendingVideoUpload({
          file: videoDraft.file,
          previewUrl: URL.createObjectURL(videoDraft.file),
          caption
        });
        const form = new FormData();
        form.append('video', videoDraft.file);
        form.append('caption', caption);
        form.append('numero', currentChat);
        try {
          clearVideoDraft();
          if (messageInput) {
            messageInput.value = '';
            messageInput.placeholder = 'Escribe un mensaje‚Ä¶';
            messageInput.focus();
          }
          const res = await fetch('/send_video', { method:'POST', body: form });
          if (!res.ok) {
            const msg = await extractSendError(res);
            throw new Error(msg);
          }
          if (pendingId) {
            updatePendingVideoUpload(pendingId, {
              state: 'queued',
              message: 'Video en cola para enviar'
            });
          }
          setVideoStatus('Video en cola para enviar', 'success', 4000);
          loadMessages();
          fetchChatList();
        } catch (err) {
          const msg = (err && err.message) ? err.message : 'No se pudo enviar el video';
          setVideoStatus(msg, 'error', 6000);
          if (pendingId) {
            updatePendingVideoUpload(pendingId, { state: 'error', message: msg });
            setTimeout(() => removePendingVideoUpload(pendingId), 6000);
          }
          alert(msg);
        } finally {
          isSendingVideo = false;
          updateSendButtons();
          if (messageInput) messageInput.focus();
        }
      }

      function handlePasteForImage(event) {
        const imageFile = extractImageFile(event.clipboardData);
        if (!imageFile) return;
        event.preventDefault();
        prepareImageDraft(imageFile);
      }

      async function sendMediaUpload(file, endpoint) {
        if (!currentChat || !file) return;
        const form = new FormData();
        form.append(endpoint.split('_')[1], file);
        const caption = messageInput ? messageInput.value.trim() : '';
        form.append('caption', caption);
        form.append('numero', currentChat);
        const isVideoUpload = endpoint === 'send_video';
        const pendingId = isVideoUpload ? addPendingVideoUpload({
          file,
          previewUrl: URL.createObjectURL(file),
          caption
        }) : null;
        if (isVideoUpload) {
          isSendingVideo = true;
          updateSendButtons();
          setVideoStatus('Procesando video‚Ä¶', 'uploading');
        }
        try {
          if (isVideoUpload && messageInput) {
            messageInput.value = '';
            messageInput.placeholder = 'Escribe un mensaje‚Ä¶';
            messageInput.focus();
          }
          const res = await fetch(`/${endpoint}`, { method:'POST', body: form });
          if (!res.ok) {
            const msg = await extractSendError(res);
            throw new Error(msg);
          }
          attachMenu.classList.remove('show');
          loadMessages(); fetchChatList();
          if (isVideoUpload) {
            setVideoStatus('Video en cola para enviar', 'success', 4000);
            if (pendingId) {
              updatePendingVideoUpload(pendingId, {
                state: 'queued',
                message: 'Video en cola para enviar'
              });
            }
          }
        } catch (err) {
          const msg = (err && err.message) ? err.message : 'No se pudo enviar el archivo';
          if (isVideoUpload) {
            setVideoStatus(msg, 'error', 6000);
            if (pendingId) {
              updatePendingVideoUpload(pendingId, { state: 'error', message: msg });
              setTimeout(() => removePendingVideoUpload(pendingId), 6000);
            }
          }
          alert(msg);
        } finally {
          if (isVideoUpload) {
            isSendingVideo = false;
            updateSendButtons();
            if (messageInput) messageInput.focus();
          }
        }
      }

      function activateDragVisual() {
        if (chatWindowEl) chatWindowEl.classList.add('drag-active');
        if (inputArea) inputArea.classList.add('drag-active');
      }

      function clearDragVisual() {
        if (chatWindowEl) chatWindowEl.classList.remove('drag-active');
        if (inputArea) inputArea.classList.remove('drag-active');
      }
      async function sendRecordedAudio(file) {
        if (!currentChat) return;
        const form = new FormData();
        form.append('audio', file);
        form.append('caption','');
        form.append('numero', currentChat);
        const res = await fetch('/send_audio', { method:'POST', body: form });
        if (!res.ok) return;
        attachMenu.classList.remove('show');
        loadMessages(); fetchChatList();
      }
      imgIn.onchange = () => {
        const selected = imgIn.files[0];
        if (selected) {
          prepareImageDraft(selected);
          imgIn.value = '';
        }
      };
      audIn.onchange = () => sendFile(audIn, 'send_audio');
      vidIn.onchange = () => sendFile(vidIn, 'send_video');
      if (clearImageDraftBtn) {
        clearImageDraftBtn.addEventListener('click', () => {
          clearImageDraft();
          if (messageInput) messageInput.focus();
        });
      }
      if (clearVideoDraftBtn) {
        clearVideoDraftBtn.addEventListener('click', () => {
          clearVideoDraft();
          if (messageInput) messageInput.focus();
        });
      }

      messageInput.addEventListener('paste', handlePasteForImage);

      function handleDragOver(event, options, container) {
        if (!event || !event.dataTransfer) return;
        const media = resolveDraggedMedia(event.dataTransfer, options);
        if (media) {
          event.preventDefault();
          event.stopPropagation();
          activateDragVisual();
        } else if (container && !container.contains(event.relatedTarget)) {
          clearDragVisual();
        }
      }

      function handleDragLeave(event, container) {
        if (container && !container.contains(event.relatedTarget)) {
          clearDragVisual();
        }
      }

      async function handleDrop(event, options) {
        const media = resolveDraggedMedia(event.dataTransfer, options);
        clearDragVisual();
        if (!media) return;
        event.preventDefault();
        event.stopPropagation();
        if (media.type === 'image') {
          prepareImageDraft(media.file);
        } else if (media.type === 'video') {
          prepareVideoDraft(media.file);
        }
      }

      if (chatWindowEl) {
        chatWindowEl.addEventListener('paste', handlePasteForImage);
        chatWindowEl.addEventListener('dragover', event => handleDragOver(event, { acceptImages: true, acceptVideos: true }, chatWindowEl));
        chatWindowEl.addEventListener('dragleave', event => handleDragLeave(event, chatWindowEl));
        chatWindowEl.addEventListener('drop', event => handleDrop(event, { acceptImages: true, acceptVideos: true }));
      }

      if (inputArea) {
        inputArea.addEventListener('dragover', event => handleDragOver(event, { acceptImages: true }, inputArea));
        inputArea.addEventListener('dragleave', event => handleDragLeave(event, inputArea));
        inputArea.addEventListener('drop', event => handleDrop(event, { acceptImages: true }));
      }

      if (messageInput) {
        messageInput.addEventListener('dragover', event => handleDragOver(event, { acceptImages: true }, inputArea || messageInput));
        messageInput.addEventListener('dragleave', event => handleDragLeave(event, inputArea || messageInput));
        messageInput.addEventListener('drop', event => handleDrop(event, { acceptImages: true }));
      }

      updateSendButtons();

      // Filtrar chats
      if (buscadorInput) {
        buscadorInput.addEventListener('input', () => fetchChatList());
      }

      // Inicializa
      setupSocket();
      fetchChatList();
      schedulePollingFallback();
    });
  </script>
{% endblock %}
