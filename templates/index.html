{% extends 'base.html' %}
{% block title %}Agestion{% endblock %}
{% block body_class %}chat{% endblock %}
{% block content %}
  <button id="menuToggle">☰</button>
  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      <h2>Chats</h2>
      <div class="sidebar-header">
        <button id="settingsBtn">⚙️</button>
      </div>
      <div id="settingsMenu">
        <a href="{{ url_for('configuracion.reglas') }}">Reglas</a>
        <a href="{{ url_for('configuracion.botones') }}">Botones</a>
        {% if session.get('roles') and 'admin' in session['roles'] %}
        <a href="{{ url_for('roles.roles') }}">Roles</a>
        {% endif %}
        <a href="{{ url_for('tablero.tablero') }}">Tablero</a>
        <a id="respuestasLink" href="{{ url_for('chat.respuestas') }}">Respuestas</a>
        <a href="{{ url_for('auth.logout') }}">Cerrar sesión</a>
      </div>
      <input id="buscador" type="text" placeholder="Buscar número…">
      <ul id="chatList"></ul>
      <button id="roleToggle">🎭</button>
      <div class="role-drop-zone">
        {% for r in roles %}
        <div class="role-icon" data-role="{{ r[2] }}">{{ r[1] }}</div>
        {% endfor %}
      </div>
    </div>

    <!-- Chat Window -->
    <div class="chatWindow">
      <div id="botonera"></div>
      <div id="chatBox"></div>
      <div id="replyPreview" class="reply-preview"></div>
      <div class="inputArea">
        <button id="attachBtn">+</button>
      <div id="attachMenu" class="attach-menu">
        <div id="attachImage" class="attach-item" title="Enviar imagen">📷</div>
        <div id="attachAudio" class="attach-item" title="Grabar audio">🎤</div>
        <div id="attachVideo" class="attach-item" title="Enviar video">🎥</div>
      </div>
      <input id="messageInput" type="text" placeholder="Escribe un mensaje…">
      <button id="sendBtn">Enviar</button>
      <input id="imageInput" type="file" accept="image/*" style="display:none;">
      <input id="audioInput" type="file" accept="audio/*" style="display:none;">
      <input id="videoInput" type="file" accept="video/*" style="display:none;">
      <div id="recordControls" class="record-controls" style="display:none;">
        <button id="startRecord" title="Grabar">⏺️</button>
        <button id="stopRecord" title="Detener" disabled>⏹️</button>
      </div>
    </div>
  </div>
</div>

  <div id="contextMenu" class="context-menu"><div id="replyAction">Responder</div></div>

  <div class="role-indicator">{{ rol }}</div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let currentChat = null, replyTo = null;
      const todosChats = new Map();
      const chatStates = {};
      let selectedBubble = null;
      const chatListEl = document.getElementById('chatList');
      const chatBoxEl  = document.getElementById('chatBox');
      const botoneraEl = document.getElementById('botonera');
      const replyPreviewEl = document.getElementById('replyPreview');
      const contextMenu = document.getElementById('contextMenu');
      const replyAction = document.getElementById('replyAction');
      const sidebar = document.querySelector('.sidebar');
      const menuToggle = document.getElementById('menuToggle');
      const searchInput = document.getElementById('buscador');
      menuToggle.addEventListener('click', () => {
        sidebar.classList.toggle('visible');
      });
      const roleToggle = document.getElementById('roleToggle');
      const roleDropZone = document.querySelector('.role-drop-zone');
      roleToggle.addEventListener('click', () => {
        roleDropZone.classList.toggle('show');
      });
        const userRole   = "{{ rol }}";
        const lastChatTimestamps = {};
        const chatItems = new Map();
        let lastChatSync = null;
        const roleIcons = { ventas: '💼', soporte: '🛠', marketing: '📣' };

        const FLOW_SUMMARY_MAX_ITEMS = 10;

        function getChatState(numero) {
          if (!chatStates[numero]) {
            chatStates[numero] = {
              count: 0,
              marker: null,
              renderedIds: new Set(),
            };
          }
          return chatStates[numero];
        }

        function normaliseTimestamp(value) {
          if (!value) return null;
          if (typeof value === 'string') {
            return value;
          }
          try {
            const date = new Date(value);
            if (!Number.isNaN(date.getTime())) {
              return date.toISOString();
            }
          } catch (err) {
            // ignore malformed values
          }
          return null;
        }

        function toMillis(value) {
          const normalised = normaliseTimestamp(value);
          if (!normalised) return null;
          const millis = Date.parse(normalised);
          return Number.isNaN(millis) ? null : millis;
        }

        function placeChatItem(li) {
          const sortKey = Number(li.dataset.sortKey || '0');
          let inserted = false;
          for (const child of chatListEl.children) {
            if (child === li) {
              continue;
            }
            const childKey = Number(child.dataset.sortKey || '0');
            if (sortKey > childKey) {
              chatListEl.insertBefore(li, child);
              inserted = true;
              break;
            }
          }
          if (!inserted) {
            chatListEl.appendChild(li);
          }
        }

        function applyChatFilter() {
          const term = (searchInput.value || '').toLowerCase();
          chatListEl.querySelectorAll('li').forEach(li => {
            const text = (li.textContent || '').toLowerCase();
            li.style.display = text.includes(term) ? '' : 'none';
          });
        }

        function ensureChatItem(numero) {
          let li = chatItems.get(numero);
          if (li) {
            return li;
          }
          li = document.createElement('li');
          li.dataset.numero = numero;
          li.draggable = true;
          li.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', numero);
          });
          li.addEventListener('click', () => selectChat(numero, li));
          li.addEventListener('contextmenu', e => {
            e.preventDefault();
            const chatData = todosChats.get(numero);
            const aliasActual = chatData && chatData.alias ? chatData.alias : '';
            const nombre = prompt("Asignar alias a: " + numero, aliasActual);
            if (nombre !== null && nombre.trim() !== "") {
              fetch('/set_alias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ numero, nombre })
              }).then(() => fetchChatList({ forceFull: true }));
            }
          });
          chatItems.set(numero, li);
          return li;
        }

        function formatFlowValue(value) {
          if (value === null || value === undefined) {
            return '—';
          }
          if (typeof value === 'boolean') {
            return value ? 'Sí' : 'No';
          }
          if (typeof value === 'number') {
            return String(value);
          }
          if (typeof value === 'string') {
            const text = value.trim();
            return text.length ? text : '—';
          }
          return String(value);
        }

        function flattenFlowData(value, prefix = []) {
          const items = [];
          if (Array.isArray(value)) {
            value.forEach((item, idx) => {
              const label = prefix.length ? `Elemento ${idx + 1}` : `Respuesta ${idx + 1}`;
              const nextPrefix = prefix.concat(label);
              if (item && typeof item === 'object') {
                items.push(...flattenFlowData(item, nextPrefix));
              } else {
                items.push({
                  label: nextPrefix.join(' › '),
                  value: formatFlowValue(item),
                });
              }
            });
            return items;
          }
          if (value && typeof value === 'object') {
            Object.entries(value).forEach(([key, val]) => {
              items.push(...flattenFlowData(val, prefix.concat(String(key))));
            });
            return items;
          }
          const label = prefix.length ? prefix.join(' › ') : 'Respuesta';
          items.push({ label, value: formatFlowValue(value) });
          return items;
        }

        function buildFlowValueNode(value) {
          if (Array.isArray(value)) {
            const list = document.createElement('ol');
            list.className = 'flow-data-list flow-data-array';
            value.forEach(item => {
              const li = document.createElement('li');
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(buildFlowValueNode(item));
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list;
          }
          if (value && typeof value === 'object') {
            const list = document.createElement('ul');
            list.className = 'flow-data-list flow-data-object';
            Object.entries(value).forEach(([key, val]) => {
              const li = document.createElement('li');
              const keySpan = document.createElement('span');
              keySpan.className = 'flow-key';
              keySpan.textContent = key;
              const wrapper = document.createElement('div');
              wrapper.className = 'flow-value-wrapper';
              wrapper.appendChild(buildFlowValueNode(val));
              li.appendChild(keySpan);
              li.appendChild(wrapper);
              list.appendChild(li);
            });
            return list;
          }
          const span = document.createElement('span');
          span.className = 'flow-value';
          span.textContent = formatFlowValue(value);
          return span;
        }

        function createFlowCard(flowName, flowJson) {
          const name = typeof flowName === 'string' ? flowName.trim() : '';
          let parsed = null;

          if (flowJson === null || flowJson === undefined) {
            parsed = null;
          } else if (typeof flowJson === 'string') {
            const raw = flowJson.trim();
            if (raw) {
              try {
                parsed = JSON.parse(raw);
              } catch (err) {
                parsed = raw;
              }
            } else {
              parsed = '';
            }
          } else if (typeof flowJson === 'object') {
            parsed = flowJson;
          } else {
            const raw = String(flowJson).trim();
            parsed = raw;
          }

          const hasRawContent = parsed !== null && parsed !== undefined;
          let hasContent = false;
          if (hasRawContent) {
            if (typeof parsed === 'string') {
              hasContent = parsed.trim().length > 0;
            } else if (Array.isArray(parsed)) {
              hasContent = parsed.length > 0;
            } else if (typeof parsed === 'object') {
              hasContent = Object.keys(parsed).length > 0;
            } else {
              hasContent = String(parsed).trim().length > 0;
            }
          }

          const hasName = name.length > 0;
          if (!hasName && !hasContent) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline';

          if (hasName) {
            const title = document.createElement('p');
            title.className = 'flow-text flow-name';
            const label = document.createElement('span');
            label.className = 'flow-label';
            label.textContent = 'Flow:';
            title.appendChild(label);
            title.appendChild(document.createTextNode(' ' + name));
            card.appendChild(title);
          }

          let appendedContent = false;

          if (hasRawContent) {
            if (parsed && typeof parsed === 'object') {
              const summaryItems = flattenFlowData(parsed);
              if (summaryItems.length) {
                const list = document.createElement('ul');
                list.className = 'flow-summary';
                summaryItems.slice(0, FLOW_SUMMARY_MAX_ITEMS).forEach(item => {
                  const li = document.createElement('li');
                  li.className = 'flow-summary-item';
                  const key = document.createElement('span');
                  key.className = 'flow-summary-key';
                  key.textContent = item.label;
                  const value = document.createElement('span');
                  value.className = 'flow-summary-value';
                  value.textContent = item.value;
                  li.appendChild(key);
                  li.appendChild(value);
                  list.appendChild(li);
                });
                card.appendChild(list);
                appendedContent = true;
                if (summaryItems.length > FLOW_SUMMARY_MAX_ITEMS) {
                  const remaining = summaryItems.length - FLOW_SUMMARY_MAX_ITEMS;
                  const more = document.createElement('div');
                  more.className = 'flow-summary-more';
                  more.textContent = `+ ${remaining} dato${remaining !== 1 ? 's' : ''} adicional${remaining !== 1 ? 'es' : ''}`;
                  card.appendChild(more);
                }
              } else {
                const isEmptyObject = parsed && !Array.isArray(parsed) && Object.keys(parsed).length === 0;
                const isEmptyArray = Array.isArray(parsed) && parsed.length === 0;
                if (isEmptyObject || isEmptyArray) {
                  const placeholder = document.createElement('p');
                  placeholder.className = 'flow-text';
                  placeholder.textContent = 'Sin contenido';
                  card.appendChild(placeholder);
                  appendedContent = true;
                } else {
                  card.appendChild(buildFlowValueNode(parsed));
                  appendedContent = true;
                }
              }
            } else if (typeof parsed === 'string') {
              const textValue = formatFlowValue(parsed);
              if (textValue && textValue !== '—') {
                const text = document.createElement('p');
                text.className = 'flow-text';
                text.textContent = textValue;
                card.appendChild(text);
                appendedContent = true;
              }
            } else {
              const text = document.createElement('p');
              text.className = 'flow-text';
              text.textContent = formatFlowValue(parsed);
              card.appendChild(text);
              appendedContent = true;
            }
          }

          if (!appendedContent && hasName) {
            const placeholder = document.createElement('p');
            placeholder.className = 'flow-text';
            placeholder.textContent = 'Sin contenido';
            card.appendChild(placeholder);
          }

          return card;
        }

        function createFlowSegmentsCard(segments, originalText) {
          if (!Array.isArray(segments) || !segments.length) {
            return null;
          }

          const card = document.createElement('div');
          card.className = 'flow-response-card flow-response-inline flow-segments-card';

          let hasContent = false;
          let userLabelShown = false;

          segments.forEach(segment => {
            if (!segment || typeof segment !== 'object') {
              return;
            }

            if (segment.kind === 'text') {
              const content = (segment.content || '').trim();
              if (!content) {
                return;
              }
              const original = (originalText || '').trim();
              if (!userLabelShown && content === original && segments.length === 1) {
                return;
              }
              const p = document.createElement('p');
              p.className = 'flow-text';
              if (!userLabelShown) {
                const label = document.createElement('span');
                label.className = 'flow-label';
                label.textContent = 'Usuario:';
                p.appendChild(label);
                p.appendChild(document.createTextNode(' ' + content));
                userLabelShown = true;
              } else {
                p.textContent = content;
              }
              card.appendChild(p);
              hasContent = true;
              return;
            }

            if (segment.kind === 'data') {
              const summary = Array.isArray(segment.summary) ? segment.summary : [];
              if (summary.length) {
                const list = document.createElement('ul');
                list.className = 'flow-summary';
                summary.slice(0, FLOW_SUMMARY_MAX_ITEMS).forEach(item => {
                  if (!item) return;
                  const li = document.createElement('li');
                  li.className = 'flow-summary-item';
                  const key = document.createElement('span');
                  key.className = 'flow-summary-key';
                  key.textContent = item.label;
                  const value = document.createElement('span');
                  value.className = 'flow-summary-value';
                  value.textContent = item.value;
                  li.appendChild(key);
                  li.appendChild(value);
                  list.appendChild(li);
                });
                card.appendChild(list);
                if (summary.length > FLOW_SUMMARY_MAX_ITEMS) {
                  const remaining = summary.length - FLOW_SUMMARY_MAX_ITEMS;
                  const more = document.createElement('div');
                  more.className = 'flow-summary-more';
                  more.textContent = `+ ${remaining} dato${remaining !== 1 ? 's' : ''} adicional${remaining !== 1 ? 'es' : ''}`;
                  card.appendChild(more);
                }
                hasContent = true;
              } else if (segment.display) {
                const pre = document.createElement('pre');
                pre.className = 'flow-json';
                pre.textContent = segment.display;
                card.appendChild(pre);
                hasContent = true;
              } else if (segment.content !== null && segment.content !== undefined) {
                const p = document.createElement('p');
                p.className = 'flow-text';
                p.textContent = formatFlowValue(segment.content);
                card.appendChild(p);
                hasContent = true;
              }
            }
          });

          return hasContent ? card : null;
        }

        function playAlertSound() {
          // El sonido de alerta se deshabilita para evitar el tono al ingresar a la interfaz.
        }

      document.querySelectorAll('.role-icon').forEach(icon => {
        icon.addEventListener('dragover', e => {
          e.preventDefault();
          icon.classList.add('drag-over');
        });
        icon.addEventListener('dragleave', () => icon.classList.remove('drag-over'));
          icon.addEventListener('drop', async e => {
            e.preventDefault();
            icon.classList.remove('drag-over');
            const numero = e.dataTransfer.getData('text/plain');
            const chat   = todosChats.get(numero);
            const role   = icon.dataset.role;
            const action = (chat && Array.isArray(chat.roles_kw) && chat.roles_kw.includes(role)) ? 'remove' : 'add';
            const res = await fetch('/assign_chat_role', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ numero, role, action })
            });
            if (res.ok) fetchChatList({ forceFull: true });
          });
        });

      document.addEventListener('click', () => contextMenu.classList.remove('show'));

      replyAction.onclick = () => {
        if (!selectedBubble) return;
        replyTo = selectedBubble.dataset.waId;
        replyPreviewEl.innerHTML = '';
        const tipo = selectedBubble.dataset.tipo || '';
        const url  = selectedBubble.dataset.url;
        const text = selectedBubble.dataset.text;
        if (url && tipo.endsWith('_image')) {
          const img = document.createElement('img');
          img.src = url; replyPreviewEl.appendChild(img);
        } else if (url && tipo.includes('audio')) {
          const a = document.createElement('audio'); a.controls=true; a.src=url; replyPreviewEl.appendChild(a);
        } else if (url && tipo.includes('video')) {
          const v = document.createElement('video'); v.controls=true; v.src=url; replyPreviewEl.appendChild(v);
        }
        if (text) {
          const p = document.createElement('p'); p.textContent = text; replyPreviewEl.appendChild(p);
        }
        replyPreviewEl.style.display = 'block';
        contextMenu.classList.remove('show');
      };

      replyPreviewEl.onclick = () => {
        replyTo = null;
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
      };

      // Mostrar u ocultar menú settings
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsMenu = document.getElementById('settingsMenu');
      settingsBtn.onclick = e => {
        e.stopPropagation();
        settingsMenu.classList.toggle('show');
      };
      document.addEventListener('click', () => settingsMenu.classList.remove('show'));


      // Cargar lista de chats
      async function fetchChatList(options = {}) {
        const { forceFull = false } = options;
        const incremental = !forceFull && lastChatSync !== null;
        const params = new URLSearchParams();
        if (incremental) {
          params.set('updated_after', new Date(lastChatSync).toISOString());
        }
        const url = params.toString() ? `/get_chat_list?${params.toString()}` : '/get_chat_list';

        let data;
        try {
          const response = await fetch(url);
          if (!response.ok) {
            return;
          }
          data = await response.json();
        } catch (err) {
          console.warn('No se pudo actualizar la lista de chats', err);
          return;
        }

        if (!Array.isArray(data)) {
          return;
        }

        const seen = new Set();
        let localMax = lastChatSync;

        data.forEach(chat => {
          if (!chat || !chat.numero) {
            return;
          }
          if (userRole !== 'admin') {
            const roles = Array.isArray(chat.roles_kw) ? chat.roles_kw : [];
            if (!roles.includes(userRole)) {
              return;
            }
          }

          const numero = chat.numero;
          const serverTime = toMillis(chat.last_timestamp);
          let modifiedTime = toMillis(chat.last_modified);
          if (modifiedTime === null) {
            modifiedTime = serverTime;
          }

          const previousTime = lastChatTimestamps[numero];
          if (serverTime && previousTime && serverTime > previousTime && numero !== currentChat) {
            const mediaPlaying = Array.from(document.querySelectorAll('audio, video')).some(m => !m.paused);
            if (!mediaPlaying) {
              playAlertSound();
            }
          }
          if (serverTime) {
            lastChatTimestamps[numero] = serverTime;
          }

          const existing = todosChats.get(numero) || {};
          const merged = { ...existing, ...chat };
          todosChats.set(numero, merged);

          const li = ensureChatItem(numero);
          li.textContent = merged.alias ? `${merged.alias} (${numero})` : numero;

          Array.from(li.classList).forEach(cls => {
            if (cls.startsWith('estado-')) {
              li.classList.remove(cls);
            }
          });
          if (merged.estado) {
            li.classList.add('estado-' + merged.estado);
          }

          if (merged.roles_kw && merged.roles_kw.length) {
            const badgeContainer = document.createElement('span');
            badgeContainer.className = 'badges';
            merged.roles_kw.forEach(r => {
              const badge = document.createElement('span');
              badge.className = 'badge';
              badge.textContent = roleIcons[r] || r.charAt(0).toUpperCase();
              badgeContainer.appendChild(badge);
            });
            li.appendChild(badgeContainer);
          }

          const sortKey = serverTime !== null ? serverTime : 0;
          li.dataset.sortKey = String(sortKey);
          if (numero === currentChat) {
            li.classList.add('active');
          } else {
            li.classList.remove('active');
          }

          seen.add(numero);
          placeChatItem(li);

          if (modifiedTime !== null) {
            if (localMax === null || modifiedTime > localMax) {
              localMax = modifiedTime;
            }
          }
        });

        if (!incremental) {
          for (const [numero, li] of chatItems.entries()) {
            if (seen.has(numero)) {
              continue;
            }
            chatItems.delete(numero);
            todosChats.delete(numero);
            delete lastChatTimestamps[numero];
            if (li.parentNode === chatListEl) {
              chatListEl.removeChild(li);
            }
            if (numero === currentChat) {
              currentChat = null;
            }
          }
        }

        if (localMax !== null) {
          lastChatSync = localMax;
        }

        applyChatFilter();
      }

      // Seleccionar chat
      function selectChat(numero, liEl) {
        currentChat = numero;
        // marcar activo
        document.querySelectorAll('#chatList li').forEach(li => li.classList.remove('active'));
        liEl.classList.add('active');
        replyTo = null;
        replyPreviewEl.style.display = 'none';
        replyPreviewEl.innerHTML = '';
        loadMessages({ resync: true });
        loadBotonera();
      }

      // Cargar mensajes
      function loadMessages(options = {}) {
        if (!currentChat) return;
        const mediaEls = chatBoxEl.querySelectorAll('audio, video');
        for (let m of mediaEls) if (!m.paused) return;

        const state = getChatState(currentChat);
        const { resync = false } = options;
        let previousCount = state.count || 0;

        if (!(state.renderedIds instanceof Set)) {
          state.renderedIds = new Set();
        }

        if (resync) {
          previousCount = 0;
          state.count = 0;
          state.marker = null;
          state.renderedIds.clear();
          chatBoxEl.innerHTML = '';
        }

        const params = new URLSearchParams();
        if (!resync && state.marker) {
          if (state.marker.timestamp) params.set('since_ts', state.marker.timestamp);
          if (state.marker.waId) params.set('last_id', state.marker.waId);
        }

        const query = params.toString();
        const requestUrl = query ? `/get_chat/${currentChat}?${query}` : `/get_chat/${currentChat}`;

        fetch(requestUrl)
          .then(r => r.json())
          .then(data => {
            const msgs = Array.isArray(data.mensajes) ? data.mensajes : [];
            const meta = data.meta || {};
            if (meta && meta.force_resync && !resync) {
              loadMessages({ resync: true });
              return;
            }

            const atBottom = resync || (chatBoxEl.scrollTop + chatBoxEl.clientHeight >= chatBoxEl.scrollHeight - 5);
            const shouldAlert = previousCount > 0;
            let alerted = false;
            let needsResync = false;

            for (const message of msgs) {
              if (needsResync) break;
              const [
                txt,
                tipo = '',
                url,
                ts,
                linkUrl,
                linkTitle,
                linkBody,
                linkThumb,
                waId,
                replyWaId,
                replyId,
                replyText,
                replyTipo,
                replyUrl,
                flowName,
                flowJson,
                flowSegments,
              ] = message;

              if (!resync && waId && state.renderedIds.has(waId)) {
                needsResync = true;
                break;
              }

              const div = document.createElement('div');
              let bubble = 'cliente';
              if (tipo && tipo.startsWith('bot')) bubble = 'bot';
              if (tipo && tipo.startsWith('asesor')) bubble = 'asesor';
              div.className = `bubble ${bubble} message`;

              if (replyWaId) {
                const replyDiv = document.createElement('div');
                replyDiv.className = 'reply';
                if (replyTipo && replyTipo.endsWith('_image') && replyUrl) {
                  const img = document.createElement('img');
                  img.src = replyUrl;
                  img.style.maxWidth = '100px';
                  replyDiv.appendChild(img);
                } else if (replyTipo && replyTipo.includes('audio') && replyUrl) {
                  const a = document.createElement('audio');
                  a.controls = true;
                  a.src = replyUrl;
                  replyDiv.appendChild(a);
                } else if (replyTipo && replyTipo.includes('video') && replyUrl) {
                  const v = document.createElement('video');
                  v.controls = true;
                  v.src = replyUrl;
                  v.style.maxWidth = '100px';
                  replyDiv.appendChild(v);
                }
                if (replyText) {
                  const p = document.createElement('p');
                  p.textContent = replyText;
                  replyDiv.appendChild(p);
                }
                div.appendChild(replyDiv);
              }

              if (tipo === 'referral' && linkUrl) {
                const a = document.createElement('a');
                a.href = linkUrl;
                a.target = '_blank';
                a.style.textDecoration = 'none';
                const card = document.createElement('div');
                card.style.display = 'flex';
                const img = document.createElement('img');
                img.src = linkThumb;
                img.style.width = '100px';
                img.style.marginRight = '8px';
                const textBox = document.createElement('div');
                textBox.innerHTML = `<strong>${linkTitle}</strong><br>${linkBody}`;
                card.appendChild(img);
                card.appendChild(textBox);
                a.appendChild(card);
                div.appendChild(a);
              } else if (tipo && tipo.endsWith('_image') && url) {
                const img = document.createElement('img');
                img.src = url;
                img.style.maxWidth = '200px';
                div.appendChild(img);
              } else if (tipo && tipo.includes('audio') && url) {
                const a = document.createElement('audio');
                a.controls = true;
                a.src = url;
                div.appendChild(a);
              } else if (tipo && tipo.includes('video') && url) {
                const v = document.createElement('video');
                v.controls = true;
                v.src = url;
                v.style.maxWidth = '200px';
                div.appendChild(v);
              }

              if (txt) {
                const p = document.createElement('p');
                p.textContent = txt;
                div.appendChild(p);
              }

              const flowCard = createFlowCard(flowName, flowJson);
              if (flowCard) {
                div.appendChild(flowCard);
              }

              const segmentsCard = createFlowSegmentsCard(flowSegments, txt);
              if (segmentsCard) {
                div.appendChild(segmentsCard);
              }

              if (ts) {
                const date = new Date(ts);
                if (!Number.isNaN(date.getTime())) {
                  const timeSpan = document.createElement('div');
                  const dia = String(date.getDate()).padStart(2, '0');
                  const mes = String(date.getMonth() + 1).padStart(2, '0');
                  const hora = String(date.getHours()).padStart(2, '0');
                  const min = String(date.getMinutes()).padStart(2, '0');
                  timeSpan.className = 'timestamp';
                  timeSpan.textContent = `${dia}/${mes} ${hora}:${min}`;
                  div.appendChild(timeSpan);
                }
              }

              if (waId) {
                div.dataset.waId = waId;
                if (txt) div.dataset.text = txt;
                if (url) div.dataset.url = url;
                div.dataset.tipo = tipo;
                div.addEventListener('contextmenu', e => {
                  e.preventDefault();
                  e.stopPropagation();
                  selectedBubble = div;
                  contextMenu.style.top = e.pageY + 'px';
                  contextMenu.style.left = e.pageX + 'px';
                  contextMenu.classList.add('show');
                });
              }

              chatBoxEl.appendChild(div);
              if (waId) {
                state.renderedIds.add(waId);
              }

              if (shouldAlert && !alerted && bubble !== 'asesor') {
                const mediaPlaying = Array.from(chatBoxEl.querySelectorAll('audio, video')).some(m => !m.paused);
                if (!mediaPlaying) {
                  playAlertSound();
                  alerted = true;
                }
              }
            }

            if (needsResync && !resync) {
              console.warn('Desincronización detectada, recargando historial completo');
              loadMessages({ resync: true });
              return;
            }

            if ((atBottom || resync) && chatBoxEl.scrollHeight) {
              chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
            }

            const lastMessage = msgs.length ? msgs[msgs.length - 1] : null;
            const metaTimestamp = meta.last_timestamp || normaliseTimestamp(lastMessage ? lastMessage[3] : null);
            const metaWaId = meta.last_wa_id || (lastMessage ? lastMessage[8] || null : null);

            if (metaTimestamp || metaWaId) {
              state.marker = {
                timestamp: metaTimestamp || (state.marker ? state.marker.timestamp : null),
                waId: metaWaId || (state.marker ? state.marker.waId : null),
              };
            }

            state.count = chatBoxEl.querySelectorAll('.message').length;
          })
          .catch(err => {
            console.error('No se pudo cargar el chat', err);
          });
      }

      // Botones rápidos
      function loadBotonera() {
        fetch('/get_botones')
          .then(r=>r.json())
          .then(btns => {
            botoneraEl.innerHTML='';
            btns.forEach((b,i) => {
              const btn = document.createElement('button');
              btn.textContent = b.nombre || i+1;
              btn.onclick = () => {
                if (!currentChat) return;
                const urls = (b.media_urls && b.media_urls.length) ? b.media_urls : [null];
                const envios = urls.map((url, index) => fetch('/send_message', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body:JSON.stringify({
                    numero: currentChat,
                    mensaje: index === 0 ? b.mensaje : '',
                    tipo_respuesta: b.tipo,
                    opciones: url,
                    reply_to_wa_id: replyTo
                  })
                }));
                Promise.all(envios).then(responses => {
                  if (responses.every(r => r.ok)) {
                    replyTo=null;
                    replyPreviewEl.style.display='none';
                    replyPreviewEl.innerHTML='';
                    loadMessages(); fetchChatList();
                  } else {
                    alert('No se pudo enviar el mensaje');
                  }
                });
              };
              botoneraEl.appendChild(btn);
            });
          });
      }

      // Enviar texto
      document.getElementById('sendBtn').onclick = () => {
        const inp = document.getElementById('messageInput');
        const txt = inp.value.trim();
        if (!txt||!currentChat) return;
        fetch('/send_message',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({numero:currentChat,mensaje:txt,reply_to_wa_id:replyTo})
        }).then(res=>{
          if(!res.ok){
            alert('No se pudo enviar el mensaje');
            return;
          }
          inp.value='';
          replyTo=null;
          replyPreviewEl.style.display='none';
          replyPreviewEl.innerHTML='';
          loadMessages(); fetchChatList();
        });
      };

      document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          document.getElementById('sendBtn').click();
        }
      });

      // Attach menu
      const attachBtn = document.getElementById('attachBtn');
      const attachMenu = document.getElementById('attachMenu');
      attachBtn.onclick = e => {
        e.stopPropagation();
        attachMenu.classList.toggle('show');
      };
      document.addEventListener('click', () => attachMenu.classList.remove('show'));

      // File inputs y grabación de audio
      const imgIn = document.getElementById('imageInput');
      const audIn = document.getElementById('audioInput');
      const vidIn = document.getElementById('videoInput');
      const recordControls = document.getElementById('recordControls');
      const startRecBtn = document.getElementById('startRecord');
      const stopRecBtn  = document.getElementById('stopRecord');
      let mediaRecorder = null;
      let audioChunks = [];
      document.getElementById('attachImage').onclick = () => imgIn.click();
      document.getElementById('attachAudio').onclick = async () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          audIn.click();
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
          mediaRecorder.onstop = async () => {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const file = new File([blob], 'recording.webm', { type: 'audio/webm' });
            await sendRecordedAudio(file);
            mediaRecorder.stream.getTracks().forEach(t=>t.stop());
          };
          recordControls.style.display = 'block';
          attachMenu.classList.remove('show');
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
        } catch(err) {
          audIn.click();
        }
      };
      document.getElementById('attachVideo').onclick = () => vidIn.click();

      startRecBtn.onclick = () => {
        if (mediaRecorder) {
          mediaRecorder.start();
          startRecBtn.disabled = true;
          stopRecBtn.disabled = false;
        }
      };
      stopRecBtn.onclick = () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          recordControls.style.display = 'none';
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
        }
      };

      async function sendFile(inputEl, endpoint) {
        if (!currentChat) return;
        const file = inputEl.files[0];
        if (!file) return;
        const form = new FormData();
        form.append(endpoint.split('_')[1], file);
        form.append('caption','');
        form.append('numero', currentChat);
        const res = await fetch(`/${endpoint}`, { method:'POST', body:form });
        if (!res.ok) return;
        inputEl.value=''; attachMenu.classList.remove('show');
        loadMessages(); fetchChatList();
      }
      async function sendRecordedAudio(file) {
        if (!currentChat) return;
        const form = new FormData();
        form.append('audio', file);
        form.append('caption','');
        form.append('numero', currentChat);
        const res = await fetch('/send_audio', { method:'POST', body: form });
        if (!res.ok) return;
        attachMenu.classList.remove('show');
        loadMessages(); fetchChatList();
      }
      imgIn.onchange = () => sendFile(imgIn, 'send_image');
      audIn.onchange = () => sendFile(audIn, 'send_audio');
      vidIn.onchange = () => sendFile(vidIn, 'send_video');

      // Filtrar chats
      searchInput.addEventListener('input', applyChatFilter);

      // Suscribirse al canal de eventos push
      const eventSource = new EventSource('/chat/stream');
      eventSource.addEventListener('message', event => {
        if (!event.data) {
          return;
        }
        let payload;
        try {
          payload = JSON.parse(event.data);
        } catch (err) {
          console.warn('Evento push inválido recibido', err);
          return;
        }
        if (!payload || payload.event !== 'mensaje') {
          return;
        }
        fetchChatList();
        if (payload.numero && payload.numero === currentChat) {
          loadMessages();
        }
      });
      eventSource.addEventListener('error', () => {
        console.warn('Canal SSE desconectado, intentando reconectar...');
      });

      // Inicializa
      fetchChatList();
    });
  </script>
{% endblock %}
